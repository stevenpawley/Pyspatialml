<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.53">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>raster – Pyspatialml: machine learning for raster datasets</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../reference/RasterLayer.html" rel="next">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Getting started</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../docs/quickstart.html"> 
<span class="menu-text">Guide</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../reference/Raster.html" aria-current="page"> 
<span class="menu-text">Reference</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../docs/landcover.html"> 
<span class="menu-text">Tutorials</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <div class="dropdown">
      <a href="" title="" id="quarto-navigation-tool-dropdown-0" class="quarto-navigation-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false" role="link" aria-label=""><i class="bi bi-github"></i></a>
      <ul class="dropdown-menu" aria-labelledby="quarto-navigation-tool-dropdown-0">
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://github.com/stevenpawley/Pyspatialml/tree/master/docs">
            Source Code
            </a>
          </li>
          <li>
            <a class="dropdown-item quarto-navbar-tools-item" href="https://github.com/stevenpawley/Pyspatialml/issues">
            Report a Bug
            </a>
          </li>
      </ul>
    </div>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../reference/Raster.html">Raster datasets</a></li><li class="breadcrumb-item"><a href="../reference/Raster.html">Raster</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Raster datasets</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/Raster.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Raster</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/RasterLayer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">RasterLayer</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Vector tools</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/vector.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">vector</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">Preprocessing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reference/preprocessing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">preprocessing</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#pyspatialml.Raster" id="toc-pyspatialml.Raster" class="nav-link active" data-scroll-target="#pyspatialml.Raster">Raster</a>
  <ul class="collapse">
  <li><a href="#attributes" id="toc-attributes" class="nav-link" data-scroll-target="#attributes">Attributes</a></li>
  <li><a href="#methods" id="toc-methods" class="nav-link" data-scroll-target="#methods">Methods</a>
  <ul class="collapse">
  <li><a href="#pyspatialml.Raster.aggregate" id="toc-pyspatialml.Raster.aggregate" class="nav-link" data-scroll-target="#pyspatialml.Raster.aggregate">aggregate</a></li>
  <li><a href="#pyspatialml.Raster.alter" id="toc-pyspatialml.Raster.alter" class="nav-link" data-scroll-target="#pyspatialml.Raster.alter">alter</a></li>
  <li><a href="#pyspatialml.Raster.append" id="toc-pyspatialml.Raster.append" class="nav-link" data-scroll-target="#pyspatialml.Raster.append">append</a></li>
  <li><a href="#pyspatialml.Raster.apply" id="toc-pyspatialml.Raster.apply" class="nav-link" data-scroll-target="#pyspatialml.Raster.apply">apply</a></li>
  <li><a href="#pyspatialml.Raster.block_shapes" id="toc-pyspatialml.Raster.block_shapes" class="nav-link" data-scroll-target="#pyspatialml.Raster.block_shapes">block_shapes</a></li>
  <li><a href="#pyspatialml.Raster.close" id="toc-pyspatialml.Raster.close" class="nav-link" data-scroll-target="#pyspatialml.Raster.close">close</a></li>
  <li><a href="#pyspatialml.Raster.copy" id="toc-pyspatialml.Raster.copy" class="nav-link" data-scroll-target="#pyspatialml.Raster.copy">copy</a></li>
  <li><a href="#pyspatialml.Raster.crop" id="toc-pyspatialml.Raster.crop" class="nav-link" data-scroll-target="#pyspatialml.Raster.crop">crop</a></li>
  <li><a href="#pyspatialml.Raster.drop" id="toc-pyspatialml.Raster.drop" class="nav-link" data-scroll-target="#pyspatialml.Raster.drop">drop</a></li>
  <li><a href="#pyspatialml.Raster.extract_raster" id="toc-pyspatialml.Raster.extract_raster" class="nav-link" data-scroll-target="#pyspatialml.Raster.extract_raster">extract_raster</a></li>
  <li><a href="#pyspatialml.Raster.extract_vector" id="toc-pyspatialml.Raster.extract_vector" class="nav-link" data-scroll-target="#pyspatialml.Raster.extract_vector">extract_vector</a></li>
  <li><a href="#pyspatialml.Raster.extract_xy" id="toc-pyspatialml.Raster.extract_xy" class="nav-link" data-scroll-target="#pyspatialml.Raster.extract_xy">extract_xy</a></li>
  <li><a href="#pyspatialml.Raster.head" id="toc-pyspatialml.Raster.head" class="nav-link" data-scroll-target="#pyspatialml.Raster.head">head</a></li>
  <li><a href="#pyspatialml.Raster.intersect" id="toc-pyspatialml.Raster.intersect" class="nav-link" data-scroll-target="#pyspatialml.Raster.intersect">intersect</a></li>
  <li><a href="#pyspatialml.Raster.mask" id="toc-pyspatialml.Raster.mask" class="nav-link" data-scroll-target="#pyspatialml.Raster.mask">mask</a></li>
  <li><a href="#pyspatialml.Raster.predict" id="toc-pyspatialml.Raster.predict" class="nav-link" data-scroll-target="#pyspatialml.Raster.predict">predict</a></li>
  <li><a href="#pyspatialml.Raster.predict_proba" id="toc-pyspatialml.Raster.predict_proba" class="nav-link" data-scroll-target="#pyspatialml.Raster.predict_proba">predict_proba</a></li>
  <li><a href="#pyspatialml.Raster.read" id="toc-pyspatialml.Raster.read" class="nav-link" data-scroll-target="#pyspatialml.Raster.read">read</a></li>
  <li><a href="#pyspatialml.Raster.rename" id="toc-pyspatialml.Raster.rename" class="nav-link" data-scroll-target="#pyspatialml.Raster.rename">rename</a></li>
  <li><a href="#pyspatialml.Raster.sample" id="toc-pyspatialml.Raster.sample" class="nav-link" data-scroll-target="#pyspatialml.Raster.sample">sample</a></li>
  <li><a href="#pyspatialml.Raster.scale" id="toc-pyspatialml.Raster.scale" class="nav-link" data-scroll-target="#pyspatialml.Raster.scale">scale</a></li>
  <li><a href="#pyspatialml.Raster.set_block_shape" id="toc-pyspatialml.Raster.set_block_shape" class="nav-link" data-scroll-target="#pyspatialml.Raster.set_block_shape">set_block_shape</a></li>
  <li><a href="#pyspatialml.Raster.tail" id="toc-pyspatialml.Raster.tail" class="nav-link" data-scroll-target="#pyspatialml.Raster.tail">tail</a></li>
  <li><a href="#pyspatialml.Raster.to_crs" id="toc-pyspatialml.Raster.to_crs" class="nav-link" data-scroll-target="#pyspatialml.Raster.to_crs">to_crs</a></li>
  <li><a href="#pyspatialml.Raster.to_pandas" id="toc-pyspatialml.Raster.to_pandas" class="nav-link" data-scroll-target="#pyspatialml.Raster.to_pandas">to_pandas</a></li>
  <li><a href="#pyspatialml.Raster.write" id="toc-pyspatialml.Raster.write" class="nav-link" data-scroll-target="#pyspatialml.Raster.write">write</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="pyspatialml.Raster" class="level1">
<h1>Raster</h1>
<p><code>Raster(self, src, crs=None, transform=None, nodata=None, file_path=None, driver=None, tempdir=tempfile.tempdir, in_memory=False)</code></p>
<p>Creates a collection of file-based GDAL-supported raster datasets that share a common coordinate reference system and geometry.</p>
<p>Raster objects encapsulate RasterLayer objects, which represent single band raster datasets that can physically be represented by either separate single-band raster files, multi-band raster files, or any combination of individual bands from multi-band raster and single-band raster datasets.</p>
<section id="attributes" class="level2">
<h2 class="anchored" data-anchor-id="attributes">Attributes</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 2%">
<col style="width: 1%">
<col style="width: 95%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>files</td>
<td>list</td>
<td>A list of the raster dataset files that are used in the Raster. This does not have to be the same length as the number of RasterLayers because some files may have multiple bands.</td>
</tr>
<tr class="even">
<td>meta</td>
<td>dict</td>
<td>A dict containing the raster metadata. The dict contains the following keys/values: crs : the crs object transform : the Affine.affine transform object width : width of the Raster in pixels height : height of the Raster in pixels count : number of RasterLayers within the Raster dtype : the numpy datatype that represents lowest common denominator of the different dtypes for all of the layers in the Raster.</td>
</tr>
<tr class="odd">
<td>names</td>
<td>list</td>
<td>A list of the RasterLayer names.</td>
</tr>
<tr class="even">
<td>block_shape</td>
<td>tuple</td>
<td>The default block_shape in (rows, cols) for reading windows of data in the Raster for out-of-memory processing.</td>
</tr>
</tbody>
</table>
</section>
<section id="methods" class="level2">
<h2 class="anchored" data-anchor-id="methods">Methods</h2>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#pyspatialml.Raster.aggregate">aggregate</a></td>
<td>Aggregates a raster to (usually) a coarser grid cell size.</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.alter">alter</a></td>
<td>Apply a fitted scikit-learn transformer to a Raster object.</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.append">append</a></td>
<td>Method to add new RasterLayers to a Raster object.</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.apply">apply</a></td>
<td>Apply user-supplied function to a Raster object.</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.block_shapes">block_shapes</a></td>
<td>Generator for windows for optimal reading and writing based</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.close">close</a></td>
<td>Close all of the RasterLayer objects in the Raster.</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.copy">copy</a></td>
<td>Creates a shallow copy of a Raster object</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.crop">crop</a></td>
<td>Crops a Raster object by the supplied bounds.</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.drop">drop</a></td>
<td>Drop individual RasterLayers from a Raster object</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.extract_raster">extract_raster</a></td>
<td>Sample a Raster object by an aligned raster of labelled pixels.</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.extract_vector">extract_vector</a></td>
<td>Sample a Raster/RasterLayer using a geopandas GeoDataframe</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.extract_xy">extract_xy</a></td>
<td>Samples pixel values using an array of xy locations.</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.head">head</a></td>
<td>Return the first 10 rows from the Raster as a ndarray</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.intersect">intersect</a></td>
<td>Perform a intersect operation on the Raster object.</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.mask">mask</a></td>
<td>Mask a Raster object based on the outline of shapes in a</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.predict">predict</a></td>
<td>Apply prediction of a scikit learn model to a Raster.</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.predict_proba">predict_proba</a></td>
<td>Apply class probability prediction of a scikit learn model to a Raster.</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.read">read</a></td>
<td>Reads data from the Raster object into a numpy array.</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.rename">rename</a></td>
<td>Rename a RasterLayer within the Raster object.</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.sample">sample</a></td>
<td>Generates a random sample of according to size, and samples</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.scale">scale</a></td>
<td>Standardize (centre and scale) a Raster object by</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.set_block_shape">set_block_shape</a></td>
<td>Set the block shape of the raster, i.e.&nbsp;the height and width</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.tail">tail</a></td>
<td>Return the last 10 rows from the Raster as a ndarray</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.to_crs">to_crs</a></td>
<td>Reprojects a Raster object to a different crs.</td>
</tr>
<tr class="odd">
<td><a href="#pyspatialml.Raster.to_pandas">to_pandas</a></td>
<td>Raster to pandas DataFrame.</td>
</tr>
<tr class="even">
<td><a href="#pyspatialml.Raster.write">write</a></td>
<td>Write the Raster object to a file.</td>
</tr>
</tbody>
</table>
<section id="pyspatialml.Raster.aggregate" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.aggregate">aggregate</h3>
<p><code>Raster.aggregate(out_shape, resampling='nearest', file_path=None, in_memory=False, driver='GTiff', dtype=None, nodata=None, **kwargs)</code></p>
<p>Aggregates a raster to (usually) a coarser grid cell size.</p>
<section id="parameters" class="level4">
<h4 class="anchored" data-anchor-id="parameters">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 7%">
<col style="width: 84%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>out_shape</code></td>
<td>tuple</td>
<td>New shape in (rows, cols).</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>resampling</code></td>
<td>str (default ‘nearest’)</td>
<td>Resampling method to use when applying decimated reads when out_shape is specified. Supported methods are: ‘average’, ‘bilinear’, ‘cubic’, ‘cubic_spline’, ‘gauss’, ‘lanczos’, ‘max’, ‘med’, ‘min’, ‘mode’, ‘q1’, ‘q3’.</td>
<td><code>'nearest'</code></td>
</tr>
<tr class="odd">
<td><code>file_path</code></td>
<td>str (optional</td>
<td>File path to save to cropped raster. If not supplied then the aggregated raster is saved to a temporary file.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>in_memory</code></td>
<td>bool</td>
<td>Whether to initiated the Raster from an array and store the data in-memory using Rasterio’s in-memory files.</td>
<td><code>is False</code></td>
</tr>
<tr class="odd">
<td><code>driver</code></td>
<td>str (default ‘GTiff’)</td>
<td>Named of GDAL-supported driver for file export.</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="even">
<td><code>dtype</code></td>
<td>str (optional</td>
<td>Coerce RasterLayers to the specified dtype. If not specified then the new intersected Raster is created using the dtype of the existing Raster dataset, which uses a dtype that can accommodate the data types of all of the individual RasterLayers.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>nodata</code></td>
<td>any number (optional</td>
<td>Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster’s dtype. Note that this does not change the pixel nodata values of the raster, it only changes the metadata of what value represents a nodata pixel.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>kwargs</code></td>
<td>opt</td>
<td>Optional named arguments to pass to the format drivers. For example can be <code>compress="deflate"</code> to add compression.</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns" class="level4">
<h4 class="anchored" data-anchor-id="returns">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 36%">
<col style="width: 63%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.raster.Raster</td>
<td>Raster object aggregated to a new pixel size.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.alter" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.alter">alter</h3>
<p><code>Raster.alter(transformer, file_path=None, in_memory=False, driver='GTiff', dtype=None, nodata=None, progress=False)</code></p>
<p>Apply a fitted scikit-learn transformer to a Raster object.</p>
<p>Can be used to transform a raster using methods such as StandardScaler, RobustScaler etc.</p>
<section id="parameters-1" class="level4">
<h4 class="anchored" data-anchor-id="parameters-1">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 20%">
<col style="width: 67%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>transformer</code></td>
<td>a sklearn.preprocessing.Transformer object</td>
<td></td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>file_path</code></td>
<td>str (optional</td>
<td>Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>in_memory</code></td>
<td>bool</td>
<td>Whether to initiated the Raster from an array and store the data in-memory using Rasterio’s in-memory files.</td>
<td><code>is False</code></td>
</tr>
<tr class="even">
<td><code>driver</code></td>
<td>str (default ‘GTiff’)</td>
<td>Named of GDAL-supported driver for file export.</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="odd">
<td><code>dtype</code></td>
<td>str (optional</td>
<td>Optionally specify a GDAL compatible data type when saving to file. If not specified, a data type is set based on the data type of the prediction.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>nodata</code></td>
<td>any number (optional</td>
<td>Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>progress</code></td>
<td>bool (default False)</td>
<td>Show progress bar for operation.</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-1" class="level4">
<h4 class="anchored" data-anchor-id="returns-1">Returns</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Pyspatialml.Raster object with transformed data.</td>
<td></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.append" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.append">append</h3>
<p><code>Raster.append(other, in_place=False)</code></p>
<p>Method to add new RasterLayers to a Raster object.</p>
<p>Note that this modifies the Raster object in-place by default.</p>
<section id="parameters-2" class="level4">
<h4 class="anchored" data-anchor-id="parameters-2">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 25%">
<col style="width: 59%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>other</code></td>
<td>Raster object, or list of Raster objects</td>
<td>Object to append to the Raster.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>in_place</code></td>
<td>bool (default False)</td>
<td>Whether to change the Raster object in-place or leave original and return a new Raster object.</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-2" class="level4">
<h4 class="anchored" data-anchor-id="returns-2">Returns</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.raster.Raster</td>
<td>Returned only if <code>in_place</code> is False</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.apply" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.apply">apply</h3>
<p><code>Raster.apply(function, file_path=None, in_memory=False, driver='GTiff', dtype=None, nodata=None, progress=False, function_args={}, **kwargs)</code></p>
<p>Apply user-supplied function to a Raster object.</p>
<section id="parameters-3" class="level4">
<h4 class="anchored" data-anchor-id="parameters-3">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 8%">
<col style="width: 80%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>function</code></td>
<td>function</td>
<td>Function that takes an numpy array as a single argument.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>file_path</code></td>
<td>str (optional</td>
<td>Optional path to save calculated Raster object. If not specified then a tempfile is used.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>in_memory</code></td>
<td>bool</td>
<td>Whether to initiated the Raster from an array and store the data in-memory using Rasterio’s in-memory files.</td>
<td><code>is False</code></td>
</tr>
<tr class="even">
<td><code>driver</code></td>
<td>str (default ‘GTiff’)</td>
<td>Named of GDAL-supported driver for file export.</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="odd">
<td><code>dtype</code></td>
<td>str (optional</td>
<td>Coerce RasterLayers to the specified dtype. If not specified then the new Raster is created using the dtype of the calculation result.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>nodata</code></td>
<td>any number (optional</td>
<td>Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster’s data type. Note that this changes the values of the pixels that represent nodata pixels.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>progress</code></td>
<td>bool (default False)</td>
<td>Optionally show progress of transform operations.</td>
<td><code>False</code></td>
</tr>
<tr class="even">
<td><code>function_args</code></td>
<td>dict(optional)</td>
<td>Optionally pass arguments to the <code>function</code> as a dict or keyword arguments.</td>
<td><code>{}</code></td>
</tr>
<tr class="odd">
<td><code>kwargs</code></td>
<td>opt</td>
<td>Optional named arguments to pass to the format drivers. For example can be <code>compress="deflate"</code> to add compression.</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-3" class="level4">
<h4 class="anchored" data-anchor-id="returns-3">Returns</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.raster.Raster</td>
<td>Raster containing the calculated result.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.block_shapes" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.block_shapes">block_shapes</h3>
<p><code>Raster.block_shapes(rows, cols)</code></p>
<p>Generator for windows for optimal reading and writing based on the raster format Windows and returns as a tuple with xoff, yoff, width, height.</p>
<section id="parameters-4" class="level4">
<h4 class="anchored" data-anchor-id="parameters-4">Parameters</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>rows</code></td>
<td>int</td>
<td>Height of window in rows.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>cols</code></td>
<td>int</td>
<td>Width of window in columns.</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.close" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.close">close</h3>
<p><code>Raster.close()</code></p>
<p>Close all of the RasterLayer objects in the Raster.</p>
<p>Note that this will cause any rasters based on temporary files to be removed. This is intended as a method of clearing temporary files that may have accumulated during an analysis session.</p>
</section>
<section id="pyspatialml.Raster.copy" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.copy">copy</h3>
<p><code>Raster.copy(subset=None)</code></p>
<p>Creates a shallow copy of a Raster object</p>
<p>Note that shallow in the context of a Raster object means that an immutable copy of the object is made, however the on-disk and in-memory file locations remain the same.</p>
<section id="parameters-5" class="level4">
<h4 class="anchored" data-anchor-id="parameters-5">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 12%">
<col style="width: 10%">
<col style="width: 62%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>subset</code></td>
<td>opt</td>
<td>A list of layer names to subset while copying.</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-4" class="level4">
<h4 class="anchored" data-anchor-id="returns-4">Returns</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.raster.Raster</td>
<td></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.crop" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.crop">crop</h3>
<p><code>Raster.crop(bounds, file_path=None, in_memory=False, driver='GTiff', dtype=None, nodata=None, **kwargs)</code></p>
<p>Crops a Raster object by the supplied bounds.</p>
<section id="parameters-6" class="level4">
<h4 class="anchored" data-anchor-id="parameters-6">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 3%">
<col style="width: 12%">
<col style="width: 80%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>bounds</code></td>
<td>tuple</td>
<td>A tuple containing the bounding box to clip by in the form of (xmin, ymin, xmax, ymax).</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>file_path</code></td>
<td>str (optional</td>
<td>File path to save to cropped raster. If not supplied then the cropped raster is saved to a temporary file.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>in_memory</code></td>
<td>bool</td>
<td>Whether to initiated the Raster from an array and store the data in-memory using Rasterio’s in-memory files.</td>
<td><code>is False</code></td>
</tr>
<tr class="even">
<td><code>driver</code></td>
<td>str (default ‘GTiff’). Default is ‘GTiff’</td>
<td>Named of GDAL-supported driver for file export.</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="odd">
<td><code>dtype</code></td>
<td>str (optional</td>
<td>Coerce RasterLayers to the specified dtype. If not specified then the new intersected Raster is created using the dtype of theexisting Raster dataset, which uses a dtype that can accommodate the data types of all of the individual RasterLayers.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>nodata</code></td>
<td>any number (optional</td>
<td>Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster’s data type. Note that this does not change the pixel nodata values of the raster, it only changes the metadata of what value represents a nodata pixel.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>kwargs</code></td>
<td>opt</td>
<td>Optional named arguments to pass to the format drivers. For example can be <code>compress="deflate"</code> to add compression.</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-5" class="level4">
<h4 class="anchored" data-anchor-id="returns-5">Returns</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.raster.Raster</td>
<td>Raster cropped to new extent.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.drop" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.drop">drop</h3>
<p><code>Raster.drop(labels, in_place=False)</code></p>
<p>Drop individual RasterLayers from a Raster object</p>
<p>Note that this modifies the Raster object in-place by default.</p>
<section id="parameters-7" class="level4">
<h4 class="anchored" data-anchor-id="parameters-7">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 17%">
<col style="width: 66%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>labels</code></td>
<td>single label or list-like</td>
<td>Index (int) or layer name to drop. Can be a single integer or label, or a list of integers or labels.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>in_place</code></td>
<td>bool (default False)</td>
<td>Whether to change the Raster object in-place or leave original and return a new Raster object.</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-6" class="level4">
<h4 class="anchored" data-anchor-id="returns-6">Returns</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.pyspatialml.Raster</td>
<td>Returned only if <code>in_place</code> is True</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.extract_raster" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.extract_raster">extract_raster</h3>
<p><code>Raster.extract_raster(src, progress=False)</code></p>
<p>Sample a Raster object by an aligned raster of labelled pixels.</p>
<section id="parameters-8" class="level4">
<h4 class="anchored" data-anchor-id="parameters-8">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 8%">
<col style="width: 71%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>src</code></td>
<td></td>
<td>Single band raster containing labelled pixels as an open rasterio DatasetReader object.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>progress</code></td>
<td>bool(opt)</td>
<td>Show a progress bar for extraction.</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-7" class="level4">
<h4 class="anchored" data-anchor-id="returns-7">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>geopandas.geopandas.GeoDataFrame</td>
<td>Geodataframe containing extracted data as point features if <code>return_array=False</code></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.extract_vector" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.extract_vector">extract_vector</h3>
<p><code>Raster.extract_vector(gdf, progress=False)</code></p>
<p>Sample a Raster/RasterLayer using a geopandas GeoDataframe containing points, lines or polygon features.</p>
<section id="parameters-9" class="level4">
<h4 class="anchored" data-anchor-id="parameters-9">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 77%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>gdf</code></td>
<td></td>
<td>Containing either point, line or polygon geometries. Overlapping geometries will cause the same pixels to be sampled.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>progress</code></td>
<td>bool(opt)</td>
<td>Show a progress bar for extraction.</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-8" class="level4">
<h4 class="anchored" data-anchor-id="returns-8">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 3%">
<col style="width: 96%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>geopandas.geopandas.GeoDataframe</td>
<td>Containing extracted data as point geometries (one point per pixel). The resulting GeoDataFrame is indexed using a named pandas.MultiIndex, with <code>pixel_idx</code> index referring to the index of each pixel that was sampled, and the <code>geometry_idx</code> index referring to the index of the each geometry in the supplied <code>gdf</code>. This makes it possible to keep track of how sampled pixel relates to the original geometries, i.e.&nbsp;multiple pixels being extracted within the area of a single polygon that can be referred to using the <code>geometry_idx</code>. The extracted data can subsequently be joined with the attribute table of the supplied <code>gdf</code> using: training_py = geopandas.read_file(nc.polygons) df = self.stack.extract_vector(gdf=training_py) df = df.dropna() df = df.merge( right=training_py.loc[:, (“id”, “label”)], left_on=“polygon_idx”, right_on=“id”, right_index=True )</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.extract_xy" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.extract_xy">extract_xy</h3>
<p><code>Raster.extract_xy(xys, return_array=False, progress=False)</code></p>
<p>Samples pixel values using an array of xy locations.</p>
<section id="parameters-10" class="level4">
<h4 class="anchored" data-anchor-id="parameters-10">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 6%">
<col style="width: 80%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>xys</code></td>
<td>2d array-like</td>
<td>x and y coordinates from which to sample the raster (n_samples, xys).</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>return_array</code></td>
<td>bool(opt)</td>
<td>By default the extracted pixel values are returned as a geopandas.GeoDataFrame. If <code>return_array=True</code> then the extracted pixel values are returned as a tuple of numpy.ndarrays.</td>
<td><code>False</code></td>
</tr>
<tr class="odd">
<td><code>progress</code></td>
<td>bool(opt)</td>
<td>Show a progress bar for extraction.</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-9" class="level4">
<h4 class="anchored" data-anchor-id="returns-9">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 27%">
<col style="width: 72%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>geopandas.geopandas.GeoDataframe</td>
<td>Containing extracted data as point geometries if <code>return_array=False</code>.</td>
</tr>
<tr class="even">
<td>numpy.numpy.ndarray</td>
<td>2d masked array containing sampled raster values (sample, bands) at the x,y locations.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.head" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.head">head</h3>
<p><code>Raster.head()</code></p>
<p>Return the first 10 rows from the Raster as a ndarray</p>
</section>
<section id="pyspatialml.Raster.intersect" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.intersect">intersect</h3>
<p><code>Raster.intersect(file_path=None, in_memory=False, driver='GTiff', dtype=None, nodata=None, **kwargs)</code></p>
<p>Perform a intersect operation on the Raster object.</p>
<p>Computes the geometric intersection of the RasterLayers with the Raster object. This will cause nodata values in any of the rasters to be propagated through all of the output rasters.</p>
<section id="parameters-11" class="level4">
<h4 class="anchored" data-anchor-id="parameters-11">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 7%">
<col style="width: 83%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>file_path</code></td>
<td>str (optional</td>
<td>File path to save to resulting Raster. If not supplied then the resulting Raster is saved to a temporary file.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>in_memory</code></td>
<td>bool</td>
<td>Whether to initiated the Raster from an array and store the data in-memory using Rasterio’s in-memory files.</td>
<td><code>is False</code></td>
</tr>
<tr class="odd">
<td><code>driver</code></td>
<td>str (default ‘GTiff’)</td>
<td>Named of GDAL-supported driver for file export.</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="even">
<td><code>dtype</code></td>
<td>str (optional</td>
<td>Coerce RasterLayers to the specified dtype. If not specified then the new intersected Raster is created using the dtype of the existing Raster dataset, which uses a dtype that can accommodate the data types of all of the individual RasterLayers.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>nodata</code></td>
<td>any number (optional</td>
<td>Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster’s data type. Note that this changes the values of the pixels that represent nodata to the new value.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>kwargs</code></td>
<td>opt</td>
<td>Optional named arguments to pass to the format drivers. For example can be <code>compress="deflate"</code> to add compression.</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-10" class="level4">
<h4 class="anchored" data-anchor-id="returns-10">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.raster.Raster</td>
<td>Raster with layers that are masked based on a union of all masks in the suite of RasterLayers.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.mask" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.mask">mask</h3>
<p><code>Raster.mask(shapes, invert=False, crop=True, pad=False, file_path=None, in_memory=False, driver='GTiff', dtype=None, nodata=None, **kwargs)</code></p>
<p>Mask a Raster object based on the outline of shapes in a geopandas.GeoDataFrame</p>
<section id="parameters-12" class="level4">
<h4 class="anchored" data-anchor-id="parameters-12">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 10%">
<col style="width: 81%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>shapes</code></td>
<td>geopandas.geopandas.GeoDataFrame</td>
<td>GeoDataFrame containing masking features.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>invert</code></td>
<td>bool (default False)</td>
<td>If False then pixels outside shapes will be masked. If True then pixels inside shape will be masked.</td>
<td><code>False</code></td>
</tr>
<tr class="odd">
<td><code>crop</code></td>
<td>bool (default True)</td>
<td>Crop the raster to the extent of the shapes.</td>
<td><code>True</code></td>
</tr>
<tr class="even">
<td><code>pad</code></td>
<td>bool (default False)</td>
<td>If True, the features will be padded in each direction by one half of a pixel prior to cropping raster.</td>
<td><code>False</code></td>
</tr>
<tr class="odd">
<td><code>file_path</code></td>
<td>str (optional</td>
<td>File path to save to resulting Raster. If not supplied then the resulting Raster is saved to a temporary file.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>in_memory</code></td>
<td>bool</td>
<td>Whether to initiated the Raster from an array and store the data in-memory using Rasterio’s in-memory files.</td>
<td><code>is False</code></td>
</tr>
<tr class="odd">
<td><code>driver</code></td>
<td>str (default ‘GTiff’)</td>
<td>Named of GDAL-supported driver for file export.</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="even">
<td><code>dtype</code></td>
<td>str (optional</td>
<td>Coerce RasterLayers to the specified dtype. If not specified then the cropped Raster is created using the existing dtype, which usesa dtype that can accommodate the data types of all of the individual RasterLayers.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>nodata</code></td>
<td>any number (optional</td>
<td>Nodata value for cropped dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster’s data type. Note that this changes the values of the pixels to the new nodata value, and changes the metadata of the raster.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>kwargs</code></td>
<td>opt</td>
<td>Optional named arguments to pass to the format drivers. For example can be <code>compress="deflate"</code> to add compression.</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-11" class="level4">
<h4 class="anchored" data-anchor-id="returns-11">Returns</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.pyspatialml.Raster</td>
<td>Raster with masked layers.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.predict" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.predict">predict</h3>
<p><code>Raster.predict(estimator, file_path=None, in_memory=False, driver='GTiff', dtype=None, nodata=None, progress=False, constants=None, **kwargs)</code></p>
<p>Apply prediction of a scikit learn model to a Raster.</p>
<p>The model can represent any scikit learn model or compatible api with a <code>fit</code> and <code>predict</code> method. These can consist of classification or regression models. Multi-class classifications and multi-target regressions are also supported.</p>
<section id="parameters-13" class="level4">
<h4 class="anchored" data-anchor-id="parameters-13">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 1%">
<col style="width: 5%">
<col style="width: 90%">
<col style="width: 1%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>estimator</code></td>
<td>estimator object implementing ‘fit’</td>
<td>The object to use to fit the data.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>file_path</code></td>
<td>str (optional</td>
<td>Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>in_memory</code></td>
<td>bool</td>
<td>Whether to initiated the Raster from an array and store the data in-memory using Rasterio’s in-memory files.</td>
<td><code>is False</code></td>
</tr>
<tr class="even">
<td><code>driver</code></td>
<td>str (default ‘GTiff’)</td>
<td>Named of GDAL-supported driver for file export</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="odd">
<td><code>dtype</code></td>
<td>str (optional</td>
<td>Optionally specify a GDAL compatible data type when saving to file. If not specified, np.float32 is assumed.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>nodata</code></td>
<td>any number (optional</td>
<td>Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>progress</code></td>
<td>bool (default False)</td>
<td>Show progress bar for prediction.</td>
<td><code>False</code></td>
</tr>
<tr class="even">
<td><code>constants</code></td>
<td></td>
<td>Constant features to add to the Raster object with each value in a list or 1d ndarray representing an additional feature. If a list-like object of values os passed, then each numeric value will be appended as constant features to the last columns in the data. It is therefore important that all features including constant features are present in the same order as what was used to train the model. If a dict is passed, then the keys of the dict must refer to the names of raster layers in the Raster object. In this case, the values of the dict will replace the values of the raster layers in the Raster object.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>kwargs</code></td>
<td>opt</td>
<td>Optional named arguments to pass to the format drivers. For example can be <code>compress="deflate"</code> to add compression.</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-12" class="level4">
<h4 class="anchored" data-anchor-id="returns-12">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 90%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.raster.Raster</td>
<td>Raster object containing prediction results as a RasterLayers. For classification and regression models, the Raster will contain a single RasterLayer, unless the model is multi-class or multi-target. Layers are named automatically as <code>pred_raw_n</code> with n = 1, 2, 3 ..n.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.predict_proba" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.predict_proba">predict_proba</h3>
<p><code>Raster.predict_proba(estimator, file_path=None, in_memory=False, indexes=None, driver='GTiff', dtype=None, nodata=None, constants=None, progress=False, **kwargs)</code></p>
<p>Apply class probability prediction of a scikit learn model to a Raster.</p>
<section id="parameters-14" class="level4">
<h4 class="anchored" data-anchor-id="parameters-14">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 1%">
<col style="width: 5%">
<col style="width: 90%">
<col style="width: 1%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>estimator</code></td>
<td>estimator object implementing ‘fit’</td>
<td>The object to use to fit the data.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>file_path</code></td>
<td>str (optional</td>
<td>Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>in_memory</code></td>
<td>bool</td>
<td>Whether to initiated the Raster from an array and store the data in-memory using Rasterio’s in-memory files.</td>
<td><code>is False</code></td>
</tr>
<tr class="even">
<td><code>indexes</code></td>
<td>list of integers (optional</td>
<td>List of class indices to export. In some circumstances, only a subset of the class probability estimations are desired, for instance when performing a binary classification only the probabilities for the positive class may be desired.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>driver</code></td>
<td>str (default ‘GTiff’)</td>
<td>Named of GDAL-supported driver for file export.</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="even">
<td><code>dtype</code></td>
<td>str (optional</td>
<td>Optionally specify a GDAL compatible data type when saving to file. If not specified, a data type is set based on the data type of the prediction.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>nodata</code></td>
<td>any number (optional</td>
<td>Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>progress</code></td>
<td>bool (default False)</td>
<td>Show progress bar for prediction.</td>
<td><code>False</code></td>
</tr>
<tr class="odd">
<td><code>constants</code></td>
<td></td>
<td>Constant features to add to the Raster object with each value in a list or 1d ndarray representing an additional feature. If a list-like object of values os passed, then each numeric value will be appended as constant features to the last columns in the data. It is therefore important that all features including constant features are present in the same order as what was used to train the model. If a dict is passed, then the keys of the dict must refer to the names of raster layers in the Raster object. In this case, the values of the dict will replace the values of the raster layers in the Raster object.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>kwargs</code></td>
<td>opt</td>
<td>Optional named arguments to pass to the format drivers. For example can be <code>compress="deflate"</code> to add compression.</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-13" class="level4">
<h4 class="anchored" data-anchor-id="returns-13">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.raster.Raster</td>
<td>Raster containing predicted class probabilities. Each predicted class is represented by a RasterLayer object. The RasterLayers are named <code>prob_n</code> for 1,2,3..n, with <code>n</code> based on the index position of the classes, not the number of the class itself. For example, a classification model predicting classes with integer values of 1, 3, and 5 would result in three RasterLayers named ‘prob_1’, ‘prob_2’ and ‘prob_3’.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.read" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.read">read</h3>
<p><code>Raster.read(masked=False, window=None, out_shape=None, resampling='nearest', as_df=False, **kwargs)</code></p>
<p>Reads data from the Raster object into a numpy array.</p>
<section id="parameters-15" class="level4">
<h4 class="anchored" data-anchor-id="parameters-15">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 14%">
<col style="width: 76%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>masked</code></td>
<td>bool (default False)</td>
<td>Read data into a masked array.</td>
<td><code>False</code></td>
</tr>
<tr class="even">
<td><code>window</code></td>
<td>rasterio.window.Window object (optional</td>
<td>Tuple of col_off, row_off, width, height of a window of data to read a chunk of data into a ndarray.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>out_shape</code></td>
<td>tuple (optional</td>
<td>Shape of shape of array (rows, cols) to read data into using decimated reads.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>resampling</code></td>
<td>str (default ‘nearest’)</td>
<td>Resampling method to use when applying decimated reads when out_shape is specified. Supported methods are: ‘average’, ‘bilinear’, ‘cubic’, ‘cubic_spline’, ‘gauss’, ‘lanczos’, ‘max’, ‘med’, ‘min’, ‘mode’, ‘q1’, ‘q3’.</td>
<td><code>'nearest'</code></td>
</tr>
<tr class="odd">
<td><code>as_df</code></td>
<td>bool (default False)</td>
<td>Whether to return the data as a pandas.DataFrame with columns named by the RasterLayer names.</td>
<td><code>False</code></td>
</tr>
<tr class="even">
<td><code>**kwargs</code></td>
<td>dict</td>
<td>Other arguments to pass to rasterio.DatasetReader.read method</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-14" class="level4">
<h4 class="anchored" data-anchor-id="returns-14">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 90%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ndarray</td>
<td>Raster values in 3d ndarray with the dimensions in order of (band, row, and column).</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.rename" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.rename">rename</h3>
<p><code>Raster.rename(names, in_place=False)</code></p>
<p>Rename a RasterLayer within the Raster object.</p>
<section id="parameters-16" class="level4">
<h4 class="anchored" data-anchor-id="parameters-16">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 14%">
<col style="width: 69%">
<col style="width: 7%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>names</code></td>
<td>dict</td>
<td>dict of old_name : new_name</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>in_place</code></td>
<td>bool (default False)</td>
<td>Whether to change names of the Raster object in-place or leave original and return a new Raster object.</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-15" class="level4">
<h4 class="anchored" data-anchor-id="returns-15">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 45%">
<col style="width: 54%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.pyspatialml.Raster</td>
<td>Returned only if <code>in_place</code> is False</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.sample" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.sample">sample</h3>
<p><code>Raster.sample(size, strata=None, return_array=False, random_state=None)</code></p>
<p>Generates a random sample of according to size, and samples the pixel values.</p>
<section id="parameters-17" class="level4">
<h4 class="anchored" data-anchor-id="parameters-17">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 8%">
<col style="width: 18%">
<col style="width: 66%">
<col style="width: 6%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>size</code></td>
<td>int</td>
<td>Number of random samples or number of samples per strata if a <code>strata</code> object is supplied.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>strata</code></td>
<td>pyspatialml Raster object (opt)</td>
<td>Whether to use stratified instead of random sampling. Strata can be supplied using another pyspatialml.Raster object.</td>
<td><code>None</code></td>
</tr>
<tr class="odd">
<td><code>return_array</code></td>
<td>bool(opt)</td>
<td>Optionally return extracted data as separate X and xy masked numpy arrays.</td>
<td><code>False</code></td>
</tr>
<tr class="even">
<td><code>random_state</code></td>
<td>int(opt)</td>
<td>integer to use within random.seed.</td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-16" class="level4">
<h4 class="anchored" data-anchor-id="returns-16">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 10%">
<col style="width: 89%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pandas.pandas.DataFrame</td>
<td>DataFrame containing values of names of RasterLayers in the Raster if <code>return_array</code> is False.</td>
</tr>
<tr class="even">
<td>tuple</td>
<td>A tuple containing two elements if <code>return_array</code> is True: - numpy.ndarray Numpy array of extracted raster values, typically 2d. - numpy.ndarray 2D numpy array of xy coordinates of extracted values.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.scale" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.scale">scale</h3>
<p><code>Raster.scale(centre=True, scale=True, file_path=None, in_memory=False, driver='GTiff', dtype=None, nodata=None, progress=False)</code></p>
<p>Standardize (centre and scale) a Raster object by subtracting the mean and dividing by the standard deviation for each layer in the object.</p>
<p>The mean and standard deviation statistics are calculated for each layer separately.</p>
<section id="parameters-18" class="level4">
<h4 class="anchored" data-anchor-id="parameters-18">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 6%">
<col style="width: 11%">
<col style="width: 75%">
<col style="width: 6%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>centre</code></td>
<td>bool</td>
<td>Whether to subtract the mean from each layer.</td>
<td><code>is True</code></td>
</tr>
<tr class="even">
<td><code>scale</code></td>
<td>bool</td>
<td>Whether to divide each layer by the standard deviation of the layer.</td>
<td><code>is True</code></td>
</tr>
<tr class="odd">
<td><code>file_path</code></td>
<td>str (optional</td>
<td>Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>in_memory</code></td>
<td>bool</td>
<td>Whether to initiated the Raster from an array and store the data in-memory using Rasterio’s in-memory files.</td>
<td><code>is False</code></td>
</tr>
<tr class="odd">
<td><code>driver</code></td>
<td>str (default ‘GTiff’)</td>
<td>Named of GDAL-supported driver for file export.</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="even">
<td><code>dtype</code></td>
<td>str (optional</td>
<td>Optionally specify a GDAL compatible data type when saving to file. If not specified, a data type is set based on the data type of the prediction.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>nodata</code></td>
<td>any number (optional</td>
<td>Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>progress</code></td>
<td>bool (default False)</td>
<td>Show progress bar for operation.</td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-17" class="level4">
<h4 class="anchored" data-anchor-id="returns-17">Returns</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Pyspatialml.Raster object with rescaled data.</td>
<td></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.set_block_shape" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.set_block_shape">set_block_shape</h3>
<p><code>Raster.set_block_shape(value)</code></p>
<p>Set the block shape of the raster, i.e.&nbsp;the height and width of windows to read in chunks for the predict, predict_proba, apply, and other supported-methods.</p>
<p>Note block shape can also be set with <code>myraster.block_shape = (500, 500)</code></p>
<section id="parameters-19" class="level4">
<h4 class="anchored" data-anchor-id="parameters-19">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 10%">
<col style="width: 62%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>value</code></td>
<td>tuple</td>
<td>A tuple of (height, width) for the block window</td>
<td><em>required</em></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.tail" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.tail">tail</h3>
<p><code>Raster.tail()</code></p>
<p>Return the last 10 rows from the Raster as a ndarray</p>
</section>
<section id="pyspatialml.Raster.to_crs" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.to_crs">to_crs</h3>
<p><code>Raster.to_crs(crs, resampling='nearest', file_path=None, in_memory=False, driver='GTiff', nodata=None, n_jobs=1, warp_mem_lim=0, progress=False, **kwargs)</code></p>
<p>Reprojects a Raster object to a different crs.</p>
<section id="parameters-20" class="level4">
<h4 class="anchored" data-anchor-id="parameters-20">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 4%">
<col style="width: 10%">
<col style="width: 81%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>crs</code></td>
<td>rasterio.transform.CRS object, or dict</td>
<td>Example: CRS({‘init’: ‘EPSG:4326’})</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>resampling</code></td>
<td>str (default ‘nearest’)</td>
<td>Resampling method to use. One of the following: nearest, bilinear, cubic, cubic_spline, lanczos, average, mode, max (GDAL &gt;= 2.2), min (GDAL &gt;= 2.2), med (GDAL &gt;= 2.2), q1 (GDAL &gt;= 2.2), q3 (GDAL &gt;= 2.2)</td>
<td><code>'nearest'</code></td>
</tr>
<tr class="odd">
<td><code>file_path</code></td>
<td>str (optional</td>
<td>Optional path to save reprojected Raster object. If not specified then a tempfile is used.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>in_memory</code></td>
<td>bool</td>
<td>Whether to initiated the Raster from an array and store the data in-memory using Rasterio’s in-memory files.</td>
<td><code>is False</code></td>
</tr>
<tr class="odd">
<td><code>driver</code></td>
<td>str (default ‘GTiff’)</td>
<td>Named of GDAL-supported driver for file export.</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="even">
<td><code>nodata</code></td>
<td>any number (optional</td>
<td>Nodata value for new dataset. If not specified then the existing nodata value of the Raster object is used, which can accommodate the dtypes of the individual layers in the Raster.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>n_jobs</code></td>
<td>int (default 1)</td>
<td>The number of warp worker threads.</td>
<td><code>1</code></td>
</tr>
<tr class="even">
<td><code>warp_mem_lim</code></td>
<td>int (default 0)</td>
<td>The warp operation memory limit in MB. Larger values allow the warp operation to be carried out in fewer chunks. The amount of memory required to warp a 3-band uint8 2000 row x 2000 col raster to a destination of the same size is approximately 56 MB. The default (0) means 64 MB with GDAL 2.2.</td>
<td><code>0</code></td>
</tr>
<tr class="odd">
<td><code>progress</code></td>
<td>bool (default False)</td>
<td>Optionally show progress of transform operations.</td>
<td><code>False</code></td>
</tr>
<tr class="even">
<td><code>kwargs</code></td>
<td>opt</td>
<td>Optional named arguments to pass to the format drivers. For example can be <code>compress="deflate"</code> to add compression.</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-18" class="level4">
<h4 class="anchored" data-anchor-id="returns-18">Returns</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.raster.Raster</td>
<td>Raster following reprojection.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.to_pandas" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.to_pandas">to_pandas</h3>
<p><code>Raster.to_pandas(max_pixels=None, resampling='nearest')</code></p>
<p>Raster to pandas DataFrame.</p>
<section id="parameters-21" class="level4">
<h4 class="anchored" data-anchor-id="parameters-21">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 9%">
<col style="width: 80%">
<col style="width: 4%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>max_pixels</code></td>
<td></td>
<td>Maximum number of pixels to sample. By default all pixels are used.</td>
<td><code>None</code></td>
</tr>
<tr class="even">
<td><code>resampling</code></td>
<td>str (default ‘nearest’)</td>
<td>Resampling method to use when applying decimated reads when out_shape is specified. Supported methods are: ‘average’, ‘bilinear’, ‘cubic’, ‘cubic_spline’, ‘gauss’, ‘lanczos’, ‘max’, ‘med’, ‘min’, ‘mode’, ‘q1’, ‘q3’.</td>
<td><code>'nearest'</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-19" class="level4">
<h4 class="anchored" data-anchor-id="returns-19">Returns</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 19%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pandas.pandas.DataFrame</td>
<td>DataFrame containing values of names of RasterLayers in the Raster as columns, and pixel values as rows.</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="pyspatialml.Raster.write" class="level3">
<h3 class="anchored" data-anchor-id="pyspatialml.Raster.write">write</h3>
<p><code>Raster.write(file_path, driver='GTiff', dtype=None, nodata=None, **kwargs)</code></p>
<p>Write the Raster object to a file.</p>
<p>Overrides the write RasterBase class method, which is a partial function of the rasterio.DatasetReader.write method.</p>
<section id="parameters-22" class="level4">
<h4 class="anchored" data-anchor-id="parameters-22">Parameters</h4>
<table class="caption-top table">
<colgroup>
<col style="width: 3%">
<col style="width: 6%">
<col style="width: 86%">
<col style="width: 3%">
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>file_path</code></td>
<td>str</td>
<td>File path used to save the Raster object.</td>
<td><em>required</em></td>
</tr>
<tr class="even">
<td><code>driver</code></td>
<td>str (default is ‘GTiff’).</td>
<td>Name of GDAL driver used to save Raster data.</td>
<td><code>'GTiff'</code></td>
</tr>
<tr class="odd">
<td><code>dtype</code></td>
<td>str (opt</td>
<td>Optionally specify a numpy compatible data type when saving to file. If not specified, a data type is selected based on the data types of RasterLayers in the Raster object.</td>
<td><code>None)</code></td>
</tr>
<tr class="even">
<td><code>nodata</code></td>
<td>any number (opt</td>
<td>Optionally assign a new nodata value when saving to file. If not specified a nodata value based on the minimum permissible value for the data types of RasterLayers in the Raster object is used. Note that this does not change the pixel nodata values of the raster, it only changes the metadata of what value represents a nodata pixel.</td>
<td><code>None)</code></td>
</tr>
<tr class="odd">
<td><code>kwargs</code></td>
<td>opt</td>
<td>Optional named arguments to pass to the format drivers. For example can be <code>compress="deflate"</code> to add compression.</td>
<td><code>{}</code></td>
</tr>
</tbody>
</table>
</section>
<section id="returns-20" class="level4">
<h4 class="anchored" data-anchor-id="returns-20">Returns</h4>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>pyspatialml.raster.Raster</td>
<td>New Raster object from saved file.</td>
</tr>
</tbody>
</table>


</section>
</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/stevenpawley\.github\.io\/Pyspatialml\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
  </div>
  <div class="nav-page nav-page-next">
      <a href="../reference/RasterLayer.html" class="pagination-link" aria-label="RasterLayer">
        <span class="nav-page-text">RasterLayer</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>