{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pyspatialml: machine learning for raster datasets Overview Pyspatialml is a Python package for applying scikit-learn machine learning models to raster-based datasets. It is inspired by the famous raster package in the R statistical programming language which has been extensively used for applying statistical and machine learning models to geospatial raster datasets. Pyspatialml includes functions and classes for working with multiple raster datasets and applying typical machine learning workflows including raster data manipulation, feature engineering on raster datasets, extraction of training data, and application of the predict or predict_proba methods of scikit-learn estimator objects to a stack of raster datasets. Pyspatialml is built upon the rasterio Python package which performs all of the heavy lifting and is designed to work with the geopandas package for related raster-vector data geoprocessing operations. Purpose A supervised machine-learning workflow as applied to spatial raster data typically involves several steps: Using vector features or labelled pixels to extract training data from a stack of raster-based predictors (e.g. spectral bands, terrain derivatives, or climate grids). The training data represent locations when some property/state/concentration is already established, and might comprise point locations of arsenic concentrations, or labelled pixels with integer-encoded values that correspond to known landcover types. Developing a machine learning classification or regression model on the training data. Pyspatialml is designed to use scikit-learn compatible api's for this purpose. Applying the fitted machine learning model to make predictions on all of the pixels in the stack of raster data. Pyspatialml is designed to make it easy to develop spatial prediction models on stacks of 2D raster datasets that are held on disk. Unlike using python's numpy module directly where raster datasets need to be held in memory, the majority of functions within pyspatialml work with raster datasets that are stored on disk and allow processing operations to be performed on datasets that are too large to be loaded into memory. Pyspatialml is designed to make it easy to work with typical raster data stacks consisting of multiple 2D grids such as different spectal bands, maps etc. However, it's purpose is not to work with multidimensional datasets, i.e. those that have more than 3 dimensions such as spacetime cubes of multiband data. The xarray package can provide a structure for this type of data. Installation Pyspatialml is available on PyPI and can be installed in the usual manner with: pip install Pyspatialml The development version, which is more up-to-date with changes to the package especially during these earlier stages of development, can be installed directly via: pip install git+https://github.com/stevenpawley/Pyspatialml","title":"About"},{"location":"#pyspatialml-machine-learning-for-raster-datasets","text":"","title":"Pyspatialml: machine learning for raster datasets"},{"location":"#overview","text":"Pyspatialml is a Python package for applying scikit-learn machine learning models to raster-based datasets. It is inspired by the famous raster package in the R statistical programming language which has been extensively used for applying statistical and machine learning models to geospatial raster datasets. Pyspatialml includes functions and classes for working with multiple raster datasets and applying typical machine learning workflows including raster data manipulation, feature engineering on raster datasets, extraction of training data, and application of the predict or predict_proba methods of scikit-learn estimator objects to a stack of raster datasets. Pyspatialml is built upon the rasterio Python package which performs all of the heavy lifting and is designed to work with the geopandas package for related raster-vector data geoprocessing operations.","title":"Overview"},{"location":"#purpose","text":"A supervised machine-learning workflow as applied to spatial raster data typically involves several steps: Using vector features or labelled pixels to extract training data from a stack of raster-based predictors (e.g. spectral bands, terrain derivatives, or climate grids). The training data represent locations when some property/state/concentration is already established, and might comprise point locations of arsenic concentrations, or labelled pixels with integer-encoded values that correspond to known landcover types. Developing a machine learning classification or regression model on the training data. Pyspatialml is designed to use scikit-learn compatible api's for this purpose. Applying the fitted machine learning model to make predictions on all of the pixels in the stack of raster data. Pyspatialml is designed to make it easy to develop spatial prediction models on stacks of 2D raster datasets that are held on disk. Unlike using python's numpy module directly where raster datasets need to be held in memory, the majority of functions within pyspatialml work with raster datasets that are stored on disk and allow processing operations to be performed on datasets that are too large to be loaded into memory. Pyspatialml is designed to make it easy to work with typical raster data stacks consisting of multiple 2D grids such as different spectal bands, maps etc. However, it's purpose is not to work with multidimensional datasets, i.e. those that have more than 3 dimensions such as spacetime cubes of multiband data. The xarray package can provide a structure for this type of data.","title":"Purpose"},{"location":"#installation","text":"Pyspatialml is available on PyPI and can be installed in the usual manner with: pip install Pyspatialml The development version, which is more up-to-date with changes to the package especially during these earlier stages of development, can be installed directly via: pip install git+https://github.com/stevenpawley/Pyspatialml","title":"Installation"},{"location":"api/","text":"Reference Raster Raster Bases: _LocIndexer , RasterStats , RasterPlot Creates a collection of file-based GDAL-supported raster datasets that share a common coordinate reference system and geometry. Raster objects encapsulate RasterLayer objects, which represent single band raster datasets that can physically be represented by either separate single-band raster files, multi-band raster files, or any combination of individual bands from multi-band raster and single-band raster datasets. Attributes list A list of the raster dataset files that are used in the Raster. This does not have to be the same length as the number of RasterLayers because some files may have multiple bands. dict A dict containing the raster metadata. The dict contains the following keys/values: crs : the crs object transform : the Affine.affine transform object width : width of the Raster in pixels height : height of the Raster in pixels count : number of RasterLayers within the Raster dtype : the numpy datatype that represents lowest common denominator of the different dtypes for all of the layers in the Raster. list A list of the RasterLayer names. tuple The default block_shape in (rows, cols) for reading windows of data in the Raster for out-of-memory processing. __init__ ( src , crs = None , transform = None , nodata = None , file_path = None , driver = None , tempdir = tempfile . tempdir , in_memory = False ) Initiate a new Raster object Parameters file path, RasterLayer, rasterio dataset, or a ndarray Initiate a Raster object from any combination of a file path or list of file paths to GDAL-supported raster datasets, RasterLayer objects, or directly from a rasterio dataset or band object that is opened in 'r' or 'rw' mode. A Raster object can also be created directly from a numpy array in [band, rows, cols] order. The additional arguments crs and transform should also be provided to supply spatial coordinate information. rasterio.crs.CRS object (optional, default is None) CRS object containing projection information for data if provided as an array. affine.Affine object (optional, default is None) Affine object containing transform information for data if provided as an array. any number (optional, default is None) Assign a nodata value to the Raster dataset when src is a ndarray. If a nodata value is not specified then it is determined based on the minimum permissible value for the array's data type. str (optional, default None) Path to save new Raster object if created from an array. str (optional, default=None) A GDAL compatible driver to use when initiating a raster from a numpy array. str, default is tempfile.tempdir Path to a directory to store temporary files that are produced during geoprocessing operations. bool, default is False Whether to initiate the Raster from an array and store the data in-memory using Rasterio's in-memory files. Returns pyspatialml.Raster Raster object containing the src layers stacked into a single object. aggregate ( out_shape , resampling = 'nearest' , file_path = None , in_memory = False , driver = 'GTiff' , dtype = None , nodata = None , ** kwargs ) Aggregates a raster to (usually) a coarser grid cell size. Parameters tuple New shape in (rows, cols). str (default 'nearest') Resampling method to use when applying decimated reads when out_shape is specified. Supported methods are: 'average', 'bilinear', 'cubic', 'cubic_spline', 'gauss', 'lanczos', 'max', 'med', 'min', 'mode', 'q1', 'q3'. str (optional, default None) File path to save to cropped raster. If not supplied then the aggregated raster is saved to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Coerce RasterLayers to the specified dtype. If not specified then the new intersected Raster is created using the dtype of the existing Raster dataset, which uses a dtype that can accommodate the data types of all of the individual RasterLayers. any number (optional, default None) Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster's dtype. Note that this does not change the pixel nodata values of the raster, it only changes the metadata of what value represents a nodata pixel. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression. Returns Raster Raster object aggregated to a new pixel size. alter ( transformer , file_path = None , in_memory = False , driver = 'GTiff' , dtype = None , nodata = None , progress = False ) Apply a fitted scikit-learn transformer to a Raster object. Can be used to transform a raster using methods such as StandardScaler, RobustScaler etc. Parameters transformer : a sklearn.preprocessing.Transformer object str (optional, default None) Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Optionally specify a GDAL compatible data type when saving to file. If not specified, a data type is set based on the data type of the prediction. any number (optional, default None) Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type. bool (default False) Show progress bar for operation. Returns Pyspatialml.Raster object with transformed data. append ( other , in_place = False ) Method to add new RasterLayers to a Raster object. Note that this modifies the Raster object in-place by default. Parameters Raster object, or list of Raster objects Object to append to the Raster. bool (default False) Whether to change the Raster object in-place or leave original and return a new Raster object. Returns Raster Returned only if in_place is False apply ( function , file_path = None , in_memory = False , driver = 'GTiff' , dtype = None , nodata = None , progress = False , function_args = {}, ** kwargs ) Apply user-supplied function to a Raster object. Parameters function Function that takes an numpy array as a single argument. str (optional, default None) Optional path to save calculated Raster object. If not specified then a tempfile is used. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Coerce RasterLayers to the specified dtype. If not specified then the new Raster is created using the dtype of the calculation result. any number (optional, default None) Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster's data type. Note that this changes the values of the pixels that represent nodata pixels. bool (default False) Optionally show progress of transform operations. dict (optional) Optionally pass arguments to the function as a dict or keyword arguments. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression. Returns Raster Raster containing the calculated result. block_shape () writable property Return the block shape in (height, width) used to read windows from the Raster block_shapes ( rows , cols ) Generator for windows for optimal reading and writing based on the raster format Windows and returns as a tuple with xoff, yoff, width, height. Parameters int Height of window in rows. int Width of window in columns. bounds () property Return the bounding box of the raster in (left, bottom, right, top) close () Close all of the RasterLayer objects in the Raster. Note that this will cause any rasters based on temporary files to be removed. This is intended as a method of clearing temporary files that may have accumulated during an analysis session. copy ( subset = None ) Creates a shallow copy of a Raster object Note that shallow in the context of a Raster object means that an immutable copy of the object is made, however the on-disk and in-memory file locations remain the same. Parameters opt A list of layer names to subset while copying. Returns Raster count () property Return the number of layers in the Raster crop ( bounds , file_path = None , in_memory = False , driver = 'GTiff' , dtype = None , nodata = None , ** kwargs ) Crops a Raster object by the supplied bounds. Parameters tuple A tuple containing the bounding box to clip by in the form of (xmin, ymin, xmax, ymax). str (optional, default None) File path to save to cropped raster. If not supplied then the cropped raster is saved to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff'). Default is 'GTiff' Named of GDAL-supported driver for file export. str (optional, default None) Coerce RasterLayers to the specified dtype. If not specified then the new intersected Raster is created using the dtype of theexisting Raster dataset, which uses a dtype that can accommodate the data types of all of the individual RasterLayers. any number (optional, default None) Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster's data type. Note that this does not change the pixel nodata values of the raster, it only changes the metadata of what value represents a nodata pixel. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression. Returns Raster Raster cropped to new extent. crs () writable property Return to crs of the Raster drop ( labels , in_place = False ) Drop individual RasterLayers from a Raster object Note that this modifies the Raster object in-place by default. Parameters single label or list-like Index (int) or layer name to drop. Can be a single integer or label, or a list of integers or labels. bool (default False) Whether to change the Raster object in-place or leave original and return a new Raster object. Returns pyspatialml.Raster Returned only if in_place is True dtypes () property Return the dtype of each layer in the Raster as a list extract_raster ( src , progress = False ) Sample a Raster object by an aligned raster of labelled pixels. Parameters rasterio DatasetReader Single band raster containing labelled pixels as an open rasterio DatasetReader object. bool (opt), default=False Show a progress bar for extraction. Returns geopandas.GeoDataFrame Geodataframe containing extracted data as point features if return_array=False extract_vector ( gdf , progress = False ) Sample a Raster/RasterLayer using a geopandas GeoDataframe containing points, lines or polygon features. Parameters geopandas.GeoDataFrame Containing either point, line or polygon geometries. Overlapping geometries will cause the same pixels to be sampled. bool (opt), default=False Show a progress bar for extraction. Returns geopandas.GeoDataframe Containing extracted data as point geometries (one point per pixel). The resulting GeoDataFrame is indexed using a named pandas.MultiIndex, with pixel_idx index referring to the index of each pixel that was sampled, and the geometry_idx index referring to the index of the each geometry in the supplied gdf . This makes it possible to keep track of how sampled pixel relates to the original geometries, i.e. multiple pixels being extracted within the area of a single polygon that can be referred to using the geometry_idx . The extracted data can subsequently be joined with the attribute table of the supplied `gdf` using: training_py = geopandas.read_file(nc.polygons) df = self.stack.extract_vector(gdf=training_py) df = df.dropna() df = df.merge( right=training_py.loc[:, (\"id\", \"label\")], left_on=\"polygon_idx\", right_on=\"id\", right_index=True ) extract_xy ( xys , return_array = False , progress = False ) Samples pixel values using an array of xy locations. Parameters 2d array-like x and y coordinates from which to sample the raster (n_samples, xys). bool (opt), default=False By default the extracted pixel values are returned as a geopandas.GeoDataFrame. If return_array=True then the extracted pixel values are returned as a tuple of numpy.ndarrays. bool (opt), default=False Show a progress bar for extraction. Returns geopandas.GeoDataframe Containing extracted data as point geometries if return_array=False . numpy.ndarray 2d masked array containing sampled raster values (sample, bands) at the x,y locations. head () Return the first 10 rows from the Raster as a ndarray height () property Return the height (number of rows) in the Raster intersect ( file_path = None , in_memory = False , driver = 'GTiff' , dtype = None , nodata = None , ** kwargs ) Perform a intersect operation on the Raster object. Computes the geometric intersection of the RasterLayers with the Raster object. This will cause nodata values in any of the rasters to be propagated through all of the output rasters. Parameters str (optional, default None) File path to save to resulting Raster. If not supplied then the resulting Raster is saved to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Coerce RasterLayers to the specified dtype. If not specified then the new intersected Raster is created using the dtype of the existing Raster dataset, which uses a dtype that can accommodate the data types of all of the individual RasterLayers. any number (optional, default None) Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster's data type. Note that this changes the values of the pixels that represent nodata to the new value. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression. Returns Raster Raster with layers that are masked based on a union of all masks in the suite of RasterLayers. mask ( shapes , invert = False , crop = True , pad = False , file_path = None , in_memory = False , driver = 'GTiff' , dtype = None , nodata = None , ** kwargs ) Mask a Raster object based on the outline of shapes in a geopandas.GeoDataFrame Parameters geopandas.GeoDataFrame GeoDataFrame containing masking features. bool (default False) If False then pixels outside shapes will be masked. If True then pixels inside shape will be masked. bool (default True) Crop the raster to the extent of the shapes. bool (default False) If True, the features will be padded in each direction by one half of a pixel prior to cropping raster. str (optional, default None) File path to save to resulting Raster. If not supplied then the resulting Raster is saved to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Coerce RasterLayers to the specified dtype. If not specified then the cropped Raster is created using the existing dtype, which usesa dtype that can accommodate the data types of all of the individual RasterLayers. any number (optional, default None) Nodata value for cropped dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster's data type. Note that this changes the values of the pixels to the new nodata value, and changes the metadata of the raster. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression. Returns pyspatialml.Raster Raster with masked layers. nodatavals () property Return the nodata value of each layer in the Raster as a list predict ( estimator , file_path = None , in_memory = False , driver = 'GTiff' , dtype = None , nodata = None , progress = False , constants = None , ** kwargs ) Apply prediction of a scikit learn model to a Raster. The model can represent any scikit learn model or compatible api with a fit and predict method. These can consist of classification or regression models. Multi-class classifications and multi-target regressions are also supported. Parameters estimator object implementing 'fit' The object to use to fit the data. str (optional, default None) Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export str (optional, default None) Optionally specify a GDAL compatible data type when saving to file. If not specified, np.float32 is assumed. any number (optional, default None) Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type. bool (default False) Show progress bar for prediction. list-like object or a dict (optional, default None) Constant features to add to the Raster object with each value in a list or 1d ndarray representing an additional feature. If a list-like object of values os passed, then each numeric value will be appended as constant features to the last columns in the data. It is therefore important that all features including constant features are present in the same order as what was used to train the model. If a dict is passed, then the keys of the dict must refer to the names of raster layers in the Raster object. In this case, the values of the dict will replace the values of the raster layers in the Raster object. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression. Returns Raster Raster object containing prediction results as a RasterLayers. For classification and regression models, the Raster will contain a single RasterLayer, unless the model is multi-class or multi-target. Layers are named automatically as pred_raw_n with n = 1, 2, 3 ..n. predict_proba ( estimator , file_path = None , in_memory = False , indexes = None , driver = 'GTiff' , dtype = None , nodata = None , constants = None , progress = False , ** kwargs ) Apply class probability prediction of a scikit learn model to a Raster. Parameters estimator object implementing 'fit' The object to use to fit the data. str (optional, default None) Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. list of integers (optional, default None) List of class indices to export. In some circumstances, only a subset of the class probability estimations are desired, for instance when performing a binary classification only the probabilities for the positive class may be desired. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Optionally specify a GDAL compatible data type when saving to file. If not specified, a data type is set based on the data type of the prediction. any number (optional, default None) Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type. bool (default False) Show progress bar for prediction. list-like object or a dict (optional, default None) Constant features to add to the Raster object with each value in a list or 1d ndarray representing an additional feature. If a list-like object of values os passed, then each numeric value will be appended as constant features to the last columns in the data. It is therefore important that all features including constant features are present in the same order as what was used to train the model. If a dict is passed, then the keys of the dict must refer to the names of raster layers in the Raster object. In this case, the values of the dict will replace the values of the raster layers in the Raster object. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression. Returns Raster Raster containing predicted class probabilities. Each predicted class is represented by a RasterLayer object. The RasterLayers are named prob_n for 1,2,3..n, with n based on the index position of the classes, not the number of the class itself. For example, a classification model predicting classes with integer values of 1, 3, and 5 would result in three RasterLayers named 'prob_1', 'prob_2' and 'prob_3'. read ( masked = False , window = None , out_shape = None , resampling = 'nearest' , as_df = False , ** kwargs ) Reads data from the Raster object into a numpy array. Parameters bool (default False) Read data into a masked array. rasterio.window.Window object (optional, default None) Tuple of col_off, row_off, width, height of a window of data to read a chunk of data into a ndarray. tuple (optional, default None) Shape of shape of array (rows, cols) to read data into using decimated reads. str (default 'nearest') Resampling method to use when applying decimated reads when out_shape is specified. Supported methods are: 'average', 'bilinear', 'cubic', 'cubic_spline', 'gauss', 'lanczos', 'max', 'med', 'min', 'mode', 'q1', 'q3'. bool (default False) Whether to return the data as a pandas.DataFrame with columns named by the RasterLayer names. **kwargs : dict Other arguments to pass to rasterio.DatasetReader.read method Returns ndarray Raster values in 3d ndarray with the dimensions in order of (band, row, and column). rename ( names , in_place = False ) Rename a RasterLayer within the Raster object. Parameters dict dict of old_name : new_name bool (default False) Whether to change names of the Raster object in-place or leave original and return a new Raster object. Returns pyspatialml.Raster Returned only if in_place is False res () property Return a tuple of the resolution of the Raster in (width, height) sample ( size , strata = None , return_array = False , random_state = None ) Generates a random sample of according to size, and samples the pixel values. Parameters int Number of random samples or number of samples per strata if a strata object is supplied. pyspatialml Raster object (opt) Whether to use stratified instead of random sampling. Strata can be supplied using another pyspatialml.Raster object. bool (opt), default=False Optionally return extracted data as separate X and xy masked numpy arrays. int (opt) integer to use within random.seed. Returns pandas.DataFrame DataFrame containing values of names of RasterLayers in the Raster if return_array is False. tuple A tuple containing two elements if return_array is True: - numpy.ndarray Numpy array of extracted raster values, typically 2d. - numpy.ndarray 2D numpy array of xy coordinates of extracted values. scale ( centre = True , scale = True , file_path = None , in_memory = False , driver = 'GTiff' , dtype = None , nodata = None , progress = False ) Standardize (centre and scale) a Raster object by subtracting the mean and dividing by the standard deviation for each layer in the object. The mean and standard deviation statistics are calculated for each layer separately. Parameters bool, default is True Whether to subtract the mean from each layer. bool, default is True Whether to divide each layer by the standard deviation of the layer. str (optional, default None) Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Optionally specify a GDAL compatible data type when saving to file. If not specified, a data type is set based on the data type of the prediction. any number (optional, default None) Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type. bool (default False) Show progress bar for operation. Returns Pyspatialml.Raster object with rescaled data. set_block_shape ( value ) Set the block shape of the raster, i.e. the height and width of windows to read in chunks for the predict, predict_proba, apply, and other supported-methods. Note block shape can also be set with myraster.block_shape = (500, 500) Parameters tuple A tuple of (height, width) for the block window shape () property Return the shape (height, width) of the Raster tail () Return the last 10 rows from the Raster as a ndarray to_crs ( crs , resampling = 'nearest' , file_path = None , in_memory = False , driver = 'GTiff' , nodata = None , n_jobs = 1 , warp_mem_lim = 0 , progress = False , ** kwargs ) Reprojects a Raster object to a different crs. Parameters rasterio.transform.CRS object, or dict Example: CRS({'init': 'EPSG:4326'}) str (default 'nearest') Resampling method to use. One of the following: nearest, bilinear, cubic, cubic_spline, lanczos, average, mode, max (GDAL >= 2.2), min (GDAL >= 2.2), med (GDAL >= 2.2), q1 (GDAL >= 2.2), q3 (GDAL >= 2.2) str (optional, default None) Optional path to save reprojected Raster object. If not specified then a tempfile is used. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. any number (optional, default None) Nodata value for new dataset. If not specified then the existing nodata value of the Raster object is used, which can accommodate the dtypes of the individual layers in the Raster. int (default 1) The number of warp worker threads. int (default 0) The warp operation memory limit in MB. Larger values allow the warp operation to be carried out in fewer chunks. The amount of memory required to warp a 3-band uint8 2000 row x 2000 col raster to a destination of the same size is approximately 56 MB. The default (0) means 64 MB with GDAL 2.2. bool (default False) Optionally show progress of transform operations. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression. Returns Raster Raster following reprojection. to_pandas ( max_pixels = None , resampling = 'nearest' ) Raster to pandas DataFrame. Parameters int (default None) Maximum number of pixels to sample. By default all pixels are used. str (default 'nearest') Resampling method to use when applying decimated reads when out_shape is specified. Supported methods are: 'average', 'bilinear', 'cubic', 'cubic_spline', 'gauss', 'lanczos', 'max', 'med', 'min', 'mode', 'q1', 'q3'. Returns pandas.DataFrame DataFrame containing values of names of RasterLayers in the Raster as columns, and pixel values as rows. transform () writable property Return the transform of the Raster width () property Return the width (number of columns) in the Raster write ( file_path , driver = 'GTiff' , dtype = None , nodata = None , ** kwargs ) Write the Raster object to a file. Overrides the write RasterBase class method, which is a partial function of the rasterio.DatasetReader.write method. Parameters str File path used to save the Raster object. str (default is 'GTiff'). Name of GDAL driver used to save Raster data. str (opt, default None) Optionally specify a numpy compatible data type when saving to file. If not specified, a data type is selected based on the data types of RasterLayers in the Raster object. any number (opt, default None) Optionally assign a new nodata value when saving to file. If not specified a nodata value based on the minimum permissible value for the data types of RasterLayers in the Raster object is used. Note that this does not change the pixel nodata values of the raster, it only changes the metadata of what value represents a nodata pixel. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression. Returns Raster New Raster object from saved file. RasterLayer Represents a single raster band derived from a single or multi-band raster dataset Simple wrapper around a rasterio.Band object with additional methods. Used because the Rasterio.Band.ds.read method reads all bands from a multi-band dataset, whereas the RasterLayer read method only reads a single band. Methods encapsulated in RasterLayer objects represent those that typically would only be applied to a single-band of a raster, i.e. sieve-clump, distance to non-NaN pixels, or arithmetic operations on individual layers. Attributes int The band index of the RasterLayer within the file dataset. str The data type of the RasterLayer. rasterio.band The underlying rasterio.band object. str A syntactically valid name for the RasterLayer. str The file path to the dataset. any number The number that is used to represent nodata pixels in the RasterLayer. str The name of the GDAL format driver. dict A python dict storing the RasterLayer metadata. affine.Affine object The affine transform parameters. int Number of layers; always equal to 1. tuple Shape of RasterLayer in (rows, columns) width, height: int The width (cols) and height (rows) of the dataset. BoundingBox named tuple A named tuple with left, bottom, right and top coordinates of the dataset. str The name of matplotlib map, or a custom matplotlib.cm.LinearSegmentedColormap or ListedColormap object. matplotlib.colors.Normalize (opt) A matplotlib.colors.Normalize to apply to the RasterLayer. This overides the norm attribute of the RasterLayer. Source code in pyspatialml/rasterlayer.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 class RasterLayer : \"\"\"Represents a single raster band derived from a single or multi-band raster dataset Simple wrapper around a rasterio.Band object with additional methods. Used because the Rasterio.Band.ds.read method reads all bands from a multi-band dataset, whereas the RasterLayer read method only reads a single band. Methods encapsulated in RasterLayer objects represent those that typically would only be applied to a single-band of a raster, i.e. sieve-clump, distance to non-NaN pixels, or arithmetic operations on individual layers. Attributes ---------- bidx : int The band index of the RasterLayer within the file dataset. dtype : str The data type of the RasterLayer. ds : rasterio.band The underlying rasterio.band object. name : str A syntactically valid name for the RasterLayer. file : str The file path to the dataset. nodata : any number The number that is used to represent nodata pixels in the RasterLayer. driver : str The name of the GDAL format driver. meta : dict A python dict storing the RasterLayer metadata. transform : affine.Affine object The affine transform parameters. count : int Number of layers; always equal to 1. shape: tuple Shape of RasterLayer in (rows, columns) width, height: int The width (cols) and height (rows) of the dataset. bounds : BoundingBox named tuple A named tuple with left, bottom, right and top coordinates of the dataset. cmap : str The name of matplotlib map, or a custom matplotlib.cm.LinearSegmentedColormap or ListedColormap object. norm : matplotlib.colors.Normalize (opt) A matplotlib.colors.Normalize to apply to the RasterLayer. This overides the norm attribute of the RasterLayer. \"\"\" def __init__ ( self , band ): \"\"\"Initiate a RasterLayer object Parameters ---------- band : a rasterio.Band object \"\"\" self . bidx = band . bidx self . dtype = band . dtype self . ds = band . ds if len ( band . ds . files ) > 0 : self . name = _make_name ( band . ds . files [ 0 ]) self . file = band . ds . files [ 0 ] else : self . name = \"in_memory\" self . file = None self . nodata = band . ds . nodata self . driver = band . ds . meta [ \"driver\" ] self . meta = band . ds . meta self . transform = band . ds . transform self . crs = band . ds . crs self . count = 1 self . shape = band . shape self . width = band . ds . width self . height = band . ds . height self . bounds = band . ds . bounds self . in_memory = False self . cmap = \"viridis\" self . norm = None self . categorical = False def close ( self ): self . ds . close () def _arith ( self , function , other = None ): \"\"\"General method for performing arithmetic operations on RasterLayer objects Parameters ---------- function : function Custom function that takes either one or two arrays, and returns a single array following a pre-defined calculation. other : pyspatialml.RasterLayer (optional, default None) If not specified, then a `function` should be provided that performs a calculation using only the selected RasterLayer. If `other` is specified, then a `function` should be supplied that takes to ndarrays as arguments and performs a calculation using both layers, i.e. layer1 - layer2. Returns ------- pyspatialml.RasterLayer Returns a single RasterLayer containing the calculated result. \"\"\" driver = self . driver if isinstance ( other , RasterLayer ): result = function ( self . read ( masked = True ), other . read ( masked = True )) else : result = function ( self . read ( masked = True )) nodata = get_nodata_value ( result . dtype ) # open output file with updated metadata meta = self . meta . copy () meta . update ( driver = driver , count = 1 , dtype = result . dtype , nodata = nodata ) with MemoryFile () as memfile : dst = memfile . open ( ** meta ) result = np . ma . filled ( result , fill_value = nodata ) dst . write ( result , indexes = 1 ) # create RasterLayer from result layer = RasterLayer ( rasterio . band ( dst , 1 )) return layer def __add__ ( self , other ): \"\"\"Implements behaviour for addition of two RasterLayers, i.e. added_layer = layer1 + layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 + arr2 return self . _arith ( func , other ) def __sub__ ( self , other ): \"\"\"Implements behaviour for subtraction of two RasterLayers, i.e. subtracted_layer = layer1 - layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 - arr2 return self . _arith ( func , other ) def __mul__ ( self , other ): \"\"\"Implements behaviour for multiplication of two RasterLayers, i.e. product = layer1 * layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 * arr2 return self . _arith ( func , other ) def __truediv__ ( self , other ): \"\"\"Implements behaviour for division using `/` of two RasterLayers, i.e. div = layer1 / layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 / arr2 return self . _arith ( func , other ) def __and__ ( self , other ): \"\"\"Implements & operator Equivalent to a intersection operation of self with other, i.e. intersected = layer1 & layer2. \"\"\" def func ( arr1 , arr2 ): mask = np . logical_and ( arr1 , arr2 ) . mask arr1 . mask [ mask ] = True return arr1 return self . _arith ( func , other ) def __or__ ( self , other ): \"\"\"Implements | operator Fills gaps in self with pixels from other. Equivalent to a union operation, i.e. union = layer1 | layer2. \"\"\" def func ( arr1 , arr2 ): idx = np . logical_or ( arr1 , arr2 . mask ) . mask arr1 [ idx ] = arr2 [ idx ] return arr1 return self . _arith ( func , other ) def __xor__ ( self , other ): \"\"\"Exclusive OR using ^ Equivalent to a symmetrical difference where the result comprises pixels that occur in self or other, but not both, i.e. xor = layer1 ^ layer2. \"\"\" def func ( arr1 , arr2 ): mask = ~ np . logical_xor ( arr1 , arr2 ) idx = np . logical_or ( arr1 , arr2 . mask ) . mask arr1 [ idx ] = arr2 [ idx ] arr1 . mask [ np . nonzero ( mask )] = True return arr1 return self . _arith ( func , other ) def __round__ ( self , ndigits ): \"\"\"Behaviour for round() function, i.e. round(layer)\"\"\" def func ( arr , ndigits ): return np . round ( arr , ndigits ) func = partial ( func , ndigits = ndigits ) return self . _arith ( func ) def __floor__ ( self ): \"\"\"Rounding down to the nearest integer using math.floor(), i.e. math.floor(layer)\"\"\" def func ( arr ): return np . floor ( arr ) return self . _arith ( func ) def __ceil__ ( self ): \"\"\"Rounding up to the nearest integer using math.ceil(), i.e. math.ceil(layer)\"\"\" def func ( arr ): return np . ceil ( arr ) return self . _arith ( func ) def __trunc__ ( self ): \"\"\"Truncating to an integral using math.trunc(), i.e. math.trunc(layer)\"\"\" def func ( arr ): return np . trunc ( arr ) return self . _arith ( func ) def __abs__ ( self ): \"\"\"abs() function as applied to a RasterLayer, i.e. abs(layer)\"\"\" def func ( arr ): return np . abs ( arr ) return self . _arith ( func ) def __pos__ ( self ): \"\"\"Unary positive, i.e. +layer1\"\"\" def func ( arr ): return np . positive ( arr ) return self . _arith ( func ) def __neg__ ( self ): \"\"\" Unary negative, i.e. -layer1 \"\"\" def func ( arr ): return np . negative ( arr ) return self . _arith ( func ) def _stats ( self , max_pixels ): \"\"\"Take a sample of pixels from which to derive per-band statistics.\"\"\" rel_width = self . shape [ 1 ] / max_pixels if rel_width > 1 : col_scaling = round ( max_pixels / rel_width ) row_scaling = max_pixels - col_scaling else : col_scaling = round ( max_pixels * rel_width ) row_scaling = max_pixels - col_scaling out_shape = ( row_scaling , col_scaling ) arr = self . read ( masked = True , out_shape = out_shape ) arr = arr . flatten () return arr def min ( self , max_pixels = 10000 ): \"\"\"Minimum value. Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The minimum value of the object \"\"\" arr = self . _stats ( max_pixels ) return np . nanmin ( arr ) def max ( self , max_pixels = 10000 ): \"\"\"Maximum value. Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The maximum value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmax ( arr ) def mean ( self , max_pixels = 10000 ): \"\"\"Mean value Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The mean value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmean ( arr ) def median ( self , max_pixels = 10000 ): \"\"\"Median value Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The medium value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmedian ( arr ) def stddev ( self , max_pixels = 10000 ): \"\"\"Standard deviation Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The standard deviation of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanstd ( arr ) def read ( self , ** kwargs ): \"\"\"Read method for a single RasterLayer. Reads the pixel values from a RasterLayer into a ndarray that always will have two dimensions in the order of (rows, columns). Parameters ---------- **kwargs : named arguments that can be passed to the the rasterio.DatasetReader.read method. \"\"\" if \"resampling\" in kwargs . keys (): resampling_methods = [ i . name for i in rasterio . enums . Resampling ] if kwargs [ \"resampling\" ] not in resampling_methods : raise ValueError ( \"Invalid resampling method. Resampling \" \"method must be one of {0} :\" . format ( resampling_methods ) ) kwargs [ \"resampling\" ] = rasterio . enums . Resampling [ kwargs [ \"resampling\" ]] return self . ds . read ( indexes = self . bidx , ** kwargs ) def write ( self , file_path , driver = \"GTiff\" , dtype = None , nodata = None , ** kwargs ): \"\"\"Write method for a single RasterLayer. Parameters ---------- file_path : str (opt) File path to save the dataset. driver : str GDAL-compatible driver used for the file format. dtype : str (opt) Numpy dtype used for the file. If omitted then the RasterLayer's dtype is used. nodata : any number (opt) A value used to represent the nodata pixels. If omitted then the RasterLayer's nodata value is used (if assigned already). kwargs : opt Optional named arguments to pass to the format drivers. For example can be `compress=\"deflate\"` to add compression. Returns ------- pyspatialml.RasterLayer \"\"\" if dtype is None : dtype = self . dtype if nodata is None : nodata = get_nodata_value ( dtype ) meta = self . ds . meta meta [ \"driver\" ] = driver meta [ \"nodata\" ] = nodata meta [ \"dtype\" ] = dtype meta . update ( kwargs ) # mask any nodata values arr = np . ma . masked_equal ( self . read (), self . nodata ) arr = arr . filled ( fill_value = nodata ) # write to file with rasterio . open ( file_path , mode = \"w\" , ** meta ) as dst : dst . write ( arr . astype ( dtype ), 1 ) src = rasterio . open ( file_path ) band = rasterio . band ( src , 1 ) layer = RasterLayer ( band ) return layer def _extract_by_indices ( self , rows , cols ): \"\"\"Spatial query of Raster object (by-band)\"\"\" X = np . ma . zeros (( len ( rows ), self . count ), dtype = \"float32\" ) arr = self . read ( masked = True ) X [:, 0 ] = arr [ rows , cols ] return X def plot ( self , cmap = None , norm = None , ax = None , cax = None , figsize = None , out_shape = ( 500 , 500 ), categorical = None , legend = False , vmin = None , vmax = None , fig_kwds = None , legend_kwds = None , ): \"\"\"Plot a RasterLayer using matplotlib.pyplot.imshow Parameters ---------- cmap : str (default None) The name of a colormap recognized by matplotlib. Overrides the cmap attribute of the RasterLayer. norm : matplotlib.colors.Normalize (opt) A matplotlib.colors.Normalize to apply to the RasterLayer. This overrides the norm attribute of the RasterLayer. ax : matplotlib.pyplot.Artist (optional, default None) axes instance on which to draw to plot. cax : matplotlib.pyplot.Artist (optional, default None) axes on which to draw the legend. figsize : tuple of integers (optional, default None) Size of the matplotlib.figure.Figure. If the ax argument is given explicitly, figsize is ignored. out_shape : tuple, default=(500, 500) Number of rows, cols to read from the raster datasets for plotting. categorical : bool (optional, default False) if True then the raster values will be considered to represent discrete values, otherwise they are considered to represent continuous values. This overrides the RasterLayer 'categorical' attribute. Setting the argument categorical to True is ignored if the RasterLayer.categorical is already True. legend : bool (optional, default False) Whether to plot the legend. vmin, xmax : scale (optional, default None) vmin and vmax define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. vmin, vmax are ignored if the norm parameter is used. fig_kwds : dict (optional, default None) Additional arguments to pass to the matplotlib.pyplot.figure call when creating the figure object. Ignored if ax is passed to the plot function. legend_kwds : dict (optional, default None) Keyword arguments to pass to matplotlib.pyplot.colorbar(). Returns ------- ax : matplotlib axes instance \"\"\" # some checks if fig_kwds is None : fig_kwds = {} if ax is None : if cax is not None : raise ValueError ( \"'ax' can not be None if 'cax' is not.\" ) fig , ax = plt . subplots ( figsize = figsize , ** fig_kwds ) ax . set_aspect ( \"equal\" ) if norm : if not isinstance ( norm , mpl . colors . Normalize ): raise AttributeError ( \"norm argument should be a \" \"matplotlib.colors.Normalize object\" ) if cmap is None : cmap = self . cmap if norm is None : norm = self . norm if legend_kwds is None : legend_kwds = {} arr = self . read ( masked = True , out_shape = out_shape ) if categorical is True : if self . categorical is False : N = np . bincount ( arr ) cmap = discrete_cmap ( N , base_cmap = cmap ) vmin , vmax = None , None im = ax . imshow ( X = arr , extent = rasterio . plot . plotting_extent ( self . ds ), cmap = cmap , norm = norm , vmin = vmin , vmax = vmax , ) if legend is True : plt . colorbar ( im , cax = cax , ax = ax , ** legend_kwds ) return ax __abs__ () abs() function as applied to a RasterLayer, i.e. abs(layer) Source code in pyspatialml/rasterlayer.py 285 286 287 288 289 290 291 def __abs__ ( self ): \"\"\"abs() function as applied to a RasterLayer, i.e. abs(layer)\"\"\" def func ( arr ): return np . abs ( arr ) return self . _arith ( func ) __add__ ( other ) Implements behaviour for addition of two RasterLayers, i.e. added_layer = layer1 + layer2 Source code in pyspatialml/rasterlayer.py 163 164 165 166 167 168 169 170 171 def __add__ ( self , other ): \"\"\"Implements behaviour for addition of two RasterLayers, i.e. added_layer = layer1 + layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 + arr2 return self . _arith ( func , other ) __and__ ( other ) Implements & operator Equivalent to a intersection operation of self with other, i.e. intersected = layer1 & layer2. Source code in pyspatialml/rasterlayer.py 203 204 205 206 207 208 209 210 211 212 213 214 215 def __and__ ( self , other ): \"\"\"Implements & operator Equivalent to a intersection operation of self with other, i.e. intersected = layer1 & layer2. \"\"\" def func ( arr1 , arr2 ): mask = np . logical_and ( arr1 , arr2 ) . mask arr1 . mask [ mask ] = True return arr1 return self . _arith ( func , other ) __ceil__ () Rounding up to the nearest integer using math.ceil(), i.e. math.ceil(layer) Source code in pyspatialml/rasterlayer.py 267 268 269 270 271 272 273 274 def __ceil__ ( self ): \"\"\"Rounding up to the nearest integer using math.ceil(), i.e. math.ceil(layer)\"\"\" def func ( arr ): return np . ceil ( arr ) return self . _arith ( func ) __floor__ () Rounding down to the nearest integer using math.floor(), i.e. math.floor(layer) Source code in pyspatialml/rasterlayer.py 258 259 260 261 262 263 264 265 def __floor__ ( self ): \"\"\"Rounding down to the nearest integer using math.floor(), i.e. math.floor(layer)\"\"\" def func ( arr ): return np . floor ( arr ) return self . _arith ( func ) __init__ ( band ) Initiate a RasterLayer object Parameters band : a rasterio.Band object Source code in pyspatialml/rasterlayer.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __init__ ( self , band ): \"\"\"Initiate a RasterLayer object Parameters ---------- band : a rasterio.Band object \"\"\" self . bidx = band . bidx self . dtype = band . dtype self . ds = band . ds if len ( band . ds . files ) > 0 : self . name = _make_name ( band . ds . files [ 0 ]) self . file = band . ds . files [ 0 ] else : self . name = \"in_memory\" self . file = None self . nodata = band . ds . nodata self . driver = band . ds . meta [ \"driver\" ] self . meta = band . ds . meta self . transform = band . ds . transform self . crs = band . ds . crs self . count = 1 self . shape = band . shape self . width = band . ds . width self . height = band . ds . height self . bounds = band . ds . bounds self . in_memory = False self . cmap = \"viridis\" self . norm = None self . categorical = False __mul__ ( other ) Implements behaviour for multiplication of two RasterLayers, i.e. product = layer1 * layer2 Source code in pyspatialml/rasterlayer.py 183 184 185 186 187 188 189 190 191 def __mul__ ( self , other ): \"\"\"Implements behaviour for multiplication of two RasterLayers, i.e. product = layer1 * layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 * arr2 return self . _arith ( func , other ) __neg__ () Unary negative, i.e. -layer1 Source code in pyspatialml/rasterlayer.py 301 302 303 304 305 306 307 308 309 def __neg__ ( self ): \"\"\" Unary negative, i.e. -layer1 \"\"\" def func ( arr ): return np . negative ( arr ) return self . _arith ( func ) __or__ ( other ) Implements | operator Fills gaps in self with pixels from other. Equivalent to a union operation, i.e. union = layer1 | layer2. Source code in pyspatialml/rasterlayer.py 217 218 219 220 221 222 223 224 225 226 227 228 229 def __or__ ( self , other ): \"\"\"Implements | operator Fills gaps in self with pixels from other. Equivalent to a union operation, i.e. union = layer1 | layer2. \"\"\" def func ( arr1 , arr2 ): idx = np . logical_or ( arr1 , arr2 . mask ) . mask arr1 [ idx ] = arr2 [ idx ] return arr1 return self . _arith ( func , other ) __pos__ () Unary positive, i.e. +layer1 Source code in pyspatialml/rasterlayer.py 293 294 295 296 297 298 299 def __pos__ ( self ): \"\"\"Unary positive, i.e. +layer1\"\"\" def func ( arr ): return np . positive ( arr ) return self . _arith ( func ) __round__ ( ndigits ) Behaviour for round() function, i.e. round(layer) Source code in pyspatialml/rasterlayer.py 248 249 250 251 252 253 254 255 256 def __round__ ( self , ndigits ): \"\"\"Behaviour for round() function, i.e. round(layer)\"\"\" def func ( arr , ndigits ): return np . round ( arr , ndigits ) func = partial ( func , ndigits = ndigits ) return self . _arith ( func ) __sub__ ( other ) Implements behaviour for subtraction of two RasterLayers, i.e. subtracted_layer = layer1 - layer2 Source code in pyspatialml/rasterlayer.py 173 174 175 176 177 178 179 180 181 def __sub__ ( self , other ): \"\"\"Implements behaviour for subtraction of two RasterLayers, i.e. subtracted_layer = layer1 - layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 - arr2 return self . _arith ( func , other ) __truediv__ ( other ) Implements behaviour for division using / of two RasterLayers, i.e. div = layer1 / layer2 Source code in pyspatialml/rasterlayer.py 193 194 195 196 197 198 199 200 201 def __truediv__ ( self , other ): \"\"\"Implements behaviour for division using `/` of two RasterLayers, i.e. div = layer1 / layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 / arr2 return self . _arith ( func , other ) __trunc__ () Truncating to an integral using math.trunc(), i.e. math.trunc(layer) Source code in pyspatialml/rasterlayer.py 276 277 278 279 280 281 282 283 def __trunc__ ( self ): \"\"\"Truncating to an integral using math.trunc(), i.e. math.trunc(layer)\"\"\" def func ( arr ): return np . trunc ( arr ) return self . _arith ( func ) __xor__ ( other ) Exclusive OR using ^ Equivalent to a symmetrical difference where the result comprises pixels that occur in self or other, but not both, i.e. xor = layer1 ^ layer2. Source code in pyspatialml/rasterlayer.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def __xor__ ( self , other ): \"\"\"Exclusive OR using ^ Equivalent to a symmetrical difference where the result comprises pixels that occur in self or other, but not both, i.e. xor = layer1 ^ layer2. \"\"\" def func ( arr1 , arr2 ): mask = ~ np . logical_xor ( arr1 , arr2 ) idx = np . logical_or ( arr1 , arr2 . mask ) . mask arr1 [ idx ] = arr2 [ idx ] arr1 . mask [ np . nonzero ( mask )] = True return arr1 return self . _arith ( func , other ) max ( max_pixels = 10000 ) Maximum value. Parameters int Number of pixels used to inform statistical estimate. Returns numpy.float32 The maximum value of the object's pixels. Source code in pyspatialml/rasterlayer.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def max ( self , max_pixels = 10000 ): \"\"\"Maximum value. Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The maximum value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmax ( arr ) mean ( max_pixels = 10000 ) Mean value Parameters int Number of pixels used to inform statistical estimate. Returns numpy.float32 The mean value of the object's pixels. Source code in pyspatialml/rasterlayer.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 def mean ( self , max_pixels = 10000 ): \"\"\"Mean value Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The mean value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmean ( arr ) median ( max_pixels = 10000 ) Median value Parameters int Number of pixels used to inform statistical estimate. Returns numpy.float32 The medium value of the object's pixels. Source code in pyspatialml/rasterlayer.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 def median ( self , max_pixels = 10000 ): \"\"\"Median value Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The medium value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmedian ( arr ) min ( max_pixels = 10000 ) Minimum value. Parameters int Number of pixels used to inform statistical estimate. Returns numpy.float32 The minimum value of the object Source code in pyspatialml/rasterlayer.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def min ( self , max_pixels = 10000 ): \"\"\"Minimum value. Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The minimum value of the object \"\"\" arr = self . _stats ( max_pixels ) return np . nanmin ( arr ) plot ( cmap = None , norm = None , ax = None , cax = None , figsize = None , out_shape = ( 500 , 500 ), categorical = None , legend = False , vmin = None , vmax = None , fig_kwds = None , legend_kwds = None ) Plot a RasterLayer using matplotlib.pyplot.imshow Parameters str (default None) The name of a colormap recognized by matplotlib. Overrides the cmap attribute of the RasterLayer. matplotlib.colors.Normalize (opt) A matplotlib.colors.Normalize to apply to the RasterLayer. This overrides the norm attribute of the RasterLayer. matplotlib.pyplot.Artist (optional, default None) axes instance on which to draw to plot. matplotlib.pyplot.Artist (optional, default None) axes on which to draw the legend. tuple of integers (optional, default None) Size of the matplotlib.figure.Figure. If the ax argument is given explicitly, figsize is ignored. tuple, default=(500, 500) Number of rows, cols to read from the raster datasets for plotting. bool (optional, default False) if True then the raster values will be considered to represent discrete values, otherwise they are considered to represent continuous values. This overrides the RasterLayer 'categorical' attribute. Setting the argument categorical to True is ignored if the RasterLayer.categorical is already True. bool (optional, default False) Whether to plot the legend. vmin, xmax : scale (optional, default None) vmin and vmax define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. vmin, vmax are ignored if the norm parameter is used. dict (optional, default None) Additional arguments to pass to the matplotlib.pyplot.figure call when creating the figure object. Ignored if ax is passed to the plot function. dict (optional, default None) Keyword arguments to pass to matplotlib.pyplot.colorbar(). Returns ax : matplotlib axes instance Source code in pyspatialml/rasterlayer.py 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 def plot ( self , cmap = None , norm = None , ax = None , cax = None , figsize = None , out_shape = ( 500 , 500 ), categorical = None , legend = False , vmin = None , vmax = None , fig_kwds = None , legend_kwds = None , ): \"\"\"Plot a RasterLayer using matplotlib.pyplot.imshow Parameters ---------- cmap : str (default None) The name of a colormap recognized by matplotlib. Overrides the cmap attribute of the RasterLayer. norm : matplotlib.colors.Normalize (opt) A matplotlib.colors.Normalize to apply to the RasterLayer. This overrides the norm attribute of the RasterLayer. ax : matplotlib.pyplot.Artist (optional, default None) axes instance on which to draw to plot. cax : matplotlib.pyplot.Artist (optional, default None) axes on which to draw the legend. figsize : tuple of integers (optional, default None) Size of the matplotlib.figure.Figure. If the ax argument is given explicitly, figsize is ignored. out_shape : tuple, default=(500, 500) Number of rows, cols to read from the raster datasets for plotting. categorical : bool (optional, default False) if True then the raster values will be considered to represent discrete values, otherwise they are considered to represent continuous values. This overrides the RasterLayer 'categorical' attribute. Setting the argument categorical to True is ignored if the RasterLayer.categorical is already True. legend : bool (optional, default False) Whether to plot the legend. vmin, xmax : scale (optional, default None) vmin and vmax define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. vmin, vmax are ignored if the norm parameter is used. fig_kwds : dict (optional, default None) Additional arguments to pass to the matplotlib.pyplot.figure call when creating the figure object. Ignored if ax is passed to the plot function. legend_kwds : dict (optional, default None) Keyword arguments to pass to matplotlib.pyplot.colorbar(). Returns ------- ax : matplotlib axes instance \"\"\" # some checks if fig_kwds is None : fig_kwds = {} if ax is None : if cax is not None : raise ValueError ( \"'ax' can not be None if 'cax' is not.\" ) fig , ax = plt . subplots ( figsize = figsize , ** fig_kwds ) ax . set_aspect ( \"equal\" ) if norm : if not isinstance ( norm , mpl . colors . Normalize ): raise AttributeError ( \"norm argument should be a \" \"matplotlib.colors.Normalize object\" ) if cmap is None : cmap = self . cmap if norm is None : norm = self . norm if legend_kwds is None : legend_kwds = {} arr = self . read ( masked = True , out_shape = out_shape ) if categorical is True : if self . categorical is False : N = np . bincount ( arr ) cmap = discrete_cmap ( N , base_cmap = cmap ) vmin , vmax = None , None im = ax . imshow ( X = arr , extent = rasterio . plot . plotting_extent ( self . ds ), cmap = cmap , norm = norm , vmin = vmin , vmax = vmax , ) if legend is True : plt . colorbar ( im , cax = cax , ax = ax , ** legend_kwds ) return ax read ( ** kwargs ) Read method for a single RasterLayer. Reads the pixel values from a RasterLayer into a ndarray that always will have two dimensions in the order of (rows, columns). Parameters **kwargs : named arguments that can be passed to the the rasterio.DatasetReader.read method. Source code in pyspatialml/rasterlayer.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 def read ( self , ** kwargs ): \"\"\"Read method for a single RasterLayer. Reads the pixel values from a RasterLayer into a ndarray that always will have two dimensions in the order of (rows, columns). Parameters ---------- **kwargs : named arguments that can be passed to the the rasterio.DatasetReader.read method. \"\"\" if \"resampling\" in kwargs . keys (): resampling_methods = [ i . name for i in rasterio . enums . Resampling ] if kwargs [ \"resampling\" ] not in resampling_methods : raise ValueError ( \"Invalid resampling method. Resampling \" \"method must be one of {0} :\" . format ( resampling_methods ) ) kwargs [ \"resampling\" ] = rasterio . enums . Resampling [ kwargs [ \"resampling\" ]] return self . ds . read ( indexes = self . bidx , ** kwargs ) stddev ( max_pixels = 10000 ) Standard deviation Parameters int Number of pixels used to inform statistical estimate. Returns numpy.float32 The standard deviation of the object's pixels. Source code in pyspatialml/rasterlayer.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 def stddev ( self , max_pixels = 10000 ): \"\"\"Standard deviation Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The standard deviation of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanstd ( arr ) write ( file_path , driver = 'GTiff' , dtype = None , nodata = None , ** kwargs ) Write method for a single RasterLayer. Parameters str (opt) File path to save the dataset. str GDAL-compatible driver used for the file format. str (opt) Numpy dtype used for the file. If omitted then the RasterLayer's dtype is used. any number (opt) A value used to represent the nodata pixels. If omitted then the RasterLayer's nodata value is used (if assigned already). opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression. Returns pyspatialml.RasterLayer Source code in pyspatialml/rasterlayer.py 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 def write ( self , file_path , driver = \"GTiff\" , dtype = None , nodata = None , ** kwargs ): \"\"\"Write method for a single RasterLayer. Parameters ---------- file_path : str (opt) File path to save the dataset. driver : str GDAL-compatible driver used for the file format. dtype : str (opt) Numpy dtype used for the file. If omitted then the RasterLayer's dtype is used. nodata : any number (opt) A value used to represent the nodata pixels. If omitted then the RasterLayer's nodata value is used (if assigned already). kwargs : opt Optional named arguments to pass to the format drivers. For example can be `compress=\"deflate\"` to add compression. Returns ------- pyspatialml.RasterLayer \"\"\" if dtype is None : dtype = self . dtype if nodata is None : nodata = get_nodata_value ( dtype ) meta = self . ds . meta meta [ \"driver\" ] = driver meta [ \"nodata\" ] = nodata meta [ \"dtype\" ] = dtype meta . update ( kwargs ) # mask any nodata values arr = np . ma . masked_equal ( self . read (), self . nodata ) arr = arr . filled ( fill_value = nodata ) # write to file with rasterio . open ( file_path , mode = \"w\" , ** meta ) as dst : dst . write ( arr . astype ( dtype ), 1 ) src = rasterio . open ( file_path ) band = rasterio . band ( src , 1 ) layer = RasterLayer ( band ) return layer GeoDistTransformer Bases: BaseEstimator , TransformerMixin Transformer to add new features based on geographical distances to reference locations. Parameters ndarray Array of coordinates of reference locations in (m, n-dimensional) order, such as {n_locations, x_coordinates, y_coordinates, ...} for as many dimensions as required. For example to calculate distances to a single x,y,z location: refs = [-57.345, -110.134, 1012] And to calculate distances to three x,y reference locations: refs = [ [-57.345, -110.134], [-56.345, -109.123], [-58.534, -112.123] ] The supplied array has to have at least x,y coordinates with a (1, 2) shape for a single location. bool, default is False Optionally calculate the minimum distance to the combined reference locations, resulting in a single new feature, rather than a new feature for each individual reference location. bool (opt), default=False Optionally log-transform the distance measures. Returns ndarray Array of shape (n_samples, n_features) with new geodistance features appended to the right-most columns of the array. Source code in pyspatialml/transformers.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 class GeoDistTransformer ( BaseEstimator , TransformerMixin ): \"\"\"Transformer to add new features based on geographical distances to reference locations. Parameters ---------- refs : ndarray Array of coordinates of reference locations in (m, n-dimensional) order, such as {n_locations, x_coordinates, y_coordinates, ...} for as many dimensions as required. For example to calculate distances to a single x,y,z location: refs = [-57.345, -110.134, 1012] And to calculate distances to three x,y reference locations: refs = [ [-57.345, -110.134], [-56.345, -109.123], [-58.534, -112.123] ] The supplied array has to have at least x,y coordinates with a (1, 2) shape for a single location. minimum : bool, default is False Optionally calculate the minimum distance to the combined reference locations, resulting in a single new feature, rather than a new feature for each individual reference location. log : bool (opt), default=False Optionally log-transform the distance measures. Returns ------- X_new : ndarray Array of shape (n_samples, n_features) with new geodistance features appended to the right-most columns of the array. \"\"\" def __init__ ( self , refs , minimum = False , log = False ): self . refs = refs self . log = log self . refs_ = None self . minimum = minimum def fit ( self , X , y = None ): self . refs_ = np . asarray ( self . refs ) if self . refs_ . ndim < 2 : raise ValueError ( \"`refs` has to be a m,n-dimensional array with at least two dimensions\" ) return self def transform ( self , X , y = None ): if self . minimum is False : dists = cdist ( self . refs_ , X ) . transpose () if self . minimum is True : tree = cKDTree ( self . refs_ ) dists , _ = tree . query ( X ) if self . log is True : dists = np . log ( dists ) return np . column_stack (( X , dists )) KNNTransformer Bases: BaseEstimator , TransformerMixin Transformer to generate new lag features by weighted aggregation of K-neighboring observations. A lag transformer uses a weighted mean/mode of the values of the K-neighboring observations to generate new lagged features. The weighted mean/mode of the surrounding observations are appended as a new feature to the right-most column in the training data. The K-neighboring observations are determined using the distance metric specified in the metric argument. The default metric is minkowski, and with p=2 is equivalent to the standard Euclidean metric. Parameters int, default = 7 Number of neighbors to use by default for kneighbors queries. {\u2018uniform\u2019, \u2018distance\u2019} or callable, default=\u2019distance\u2019 Weight function used in prediction. Possible values: - \u2018uniform\u2019 : uniform weights. All points in each neighborhood are weighted equally. - \u2018distance\u2019 : weight points by the inverse of their distance. In this case, closer neighbors of a query point will have a greater influence than neighbors which are further away. - [callable] : a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights. {'mean', 'mode'} Function that is used to apply the weights to y . Use 'mean' if the target variable is continuous and 'mode' if the target variable is discrete. float, default=1.0 Range of parameter space to use by default for radius_neighbors queries. {\u2018auto\u2019, \u2018ball_tree\u2019, \u2018kd_tree\u2019, \u2018brute\u2019}, default=\u2019auto\u2019 Algorithm used to compute the nearest neighbors: - \u2018ball_tree\u2019 will use BallTree - \u2018kd_tree\u2019 will use KDTree - \u2018brute\u2019 will use a brute-force search. - \u2018auto\u2019 will attempt to decide the most appropriate algorithm based on the values passed to fit method. - Note: fitting on sparse input will override the setting of this parameter, using brute force. int, default=30 Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem. str or callable, default=\u2019minkowski\u2019 The distance metric to use for the tree. The default metric is minkowski, and with p=2 is equivalent to the standard Euclidean metric. See the documentation of DistanceMetric for a list of available metrics. If metric is \u201cprecomputed\u201d, X is assumed to be a distance matrix and must be square during fit. X may be a sparse graph, in which case only \u201cnonzero\u201d elements may be considered neighbors. int, default=2 Parameter for the Minkowski metric from sklearn.metrics.pairwise.pairwise_distances. When p = 1, this is equivalent to using manhattan_distance (l1), and euclidean_distance (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used. bool, default=True Whether to normalize the inputs using sklearn.preprocessing.Normalizer dict, default=None Additional keyword arguments for the metric function. dict, default=None Additional keyword arguments to pass to a custom kernel function. int, default=None The number of parallel jobs to run for neighbors search. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details. Source code in pyspatialml/transformers.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 class KNNTransformer ( BaseEstimator , TransformerMixin ): \"\"\"Transformer to generate new lag features by weighted aggregation of K-neighboring observations. A lag transformer uses a weighted mean/mode of the values of the K-neighboring observations to generate new lagged features. The weighted mean/mode of the surrounding observations are appended as a new feature to the right-most column in the training data. The K-neighboring observations are determined using the distance metric specified in the `metric` argument. The default metric is minkowski, and with p=2 is equivalent to the standard Euclidean metric. Parameters ---------- n_neighbors : int, default = 7 Number of neighbors to use by default for kneighbors queries. weights : {\u2018uniform\u2019, \u2018distance\u2019} or callable, default=\u2019distance\u2019 Weight function used in prediction. Possible values: - \u2018uniform\u2019 : uniform weights. All points in each neighborhood are weighted equally. - \u2018distance\u2019 : weight points by the inverse of their distance. In this case, closer neighbors of a query point will have a greater influence than neighbors which are further away. - [callable] : a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights. measure : {'mean', 'mode'} Function that is used to apply the weights to `y`. Use 'mean' if the target variable is continuous and 'mode' if the target variable is discrete. radius : float, default=1.0 Range of parameter space to use by default for radius_neighbors queries. algorithm: {\u2018auto\u2019, \u2018ball_tree\u2019, \u2018kd_tree\u2019, \u2018brute\u2019}, default=\u2019auto\u2019 Algorithm used to compute the nearest neighbors: - \u2018ball_tree\u2019 will use BallTree - \u2018kd_tree\u2019 will use KDTree - \u2018brute\u2019 will use a brute-force search. - \u2018auto\u2019 will attempt to decide the most appropriate algorithm based on the values passed to fit method. - Note: fitting on sparse input will override the setting of this parameter, using brute force. leaf_size : int, default=30 Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem. metric : str or callable, default=\u2019minkowski\u2019 The distance metric to use for the tree. The default metric is minkowski, and with p=2 is equivalent to the standard Euclidean metric. See the documentation of DistanceMetric for a list of available metrics. If metric is \u201cprecomputed\u201d, X is assumed to be a distance matrix and must be square during fit. X may be a sparse graph, in which case only \u201cnonzero\u201d elements may be considered neighbors. p : int, default=2 Parameter for the Minkowski metric from sklearn.metrics.pairwise.pairwise_distances. When p = 1, this is equivalent to using manhattan_distance (l1), and euclidean_distance (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used. normalize : bool, default=True Whether to normalize the inputs using sklearn.preprocessing.Normalizer metric_params : dict, default=None Additional keyword arguments for the metric function. kernel_params : dict, default=None Additional keyword arguments to pass to a custom kernel function. n_jobs : int, default=None The number of parallel jobs to run for neighbors search. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details. \"\"\" def __init__ ( self , n_neighbors = 7 , weights = \"distance\" , measure = \"mean\" , radius = 1.0 , algorithm = \"auto\" , leaf_size = 30 , metric = \"minkowski\" , p = 2 , normalize = True , metric_params = None , kernel_params = None , n_jobs = 1 , ): self . n_neighbors = n_neighbors self . weights = weights self . measure = measure self . radius = radius self . algorithm = algorithm self . leaf_size = leaf_size self . metric = metric self . p = p self . metric_params = metric_params self . kernel_params = kernel_params self . normalize = normalize self . n_jobs = n_jobs self . knn = NearestNeighbors ( n_neighbors = self . n_neighbors , radius = self . radius , algorithm = self . algorithm , leaf_size = self . leaf_size , metric = self . metric , p = self . p , metric_params = self . metric_params , n_jobs = self . n_jobs , ) self . y_ = None def fit ( self , X , y = None ): \"\"\"Fit the base_estimator with features from X {n_samples, n_features} and with an additional spatially lagged variable added to the right-most column of the training data. During fitting, the k-neighbors to each training point are used to estimate the spatial lag component. The training point is not included in the calculation, i.e. the training point is not considered its own neighbor. Parameters ---------- X : array-like of sample {n_samples, n_features} using for model fitting The training input samples y : array-like of shape (n_samples,) The target values (class labels in classification, real numbers in regression). \"\"\" # some checks if self . kernel_params is None : self . kernel_params = {} if y . ndim == 1 : self . n_outputs_ = 1 else : self . n_outputs_ = y . shape [ 1 ] # fit knn and get values of neighbors if self . normalize is True : scaler = Normalizer () X = scaler . fit_transform ( X ) self . scaler_ = scaler self . knn . fit ( X ) self . y_ = y . copy () return self def transform ( self , X , y = None ): \"\"\"Transform method for spatial lag models. Augments new observations with a spatial lag variable created from a weighted mean/mode (regression/classification) of k-neighboring observations. Parameters ---------- X : array-like of sample {n_samples, n_features} New samples for the prediction. y : None Not used. \"\"\" # get distances from training points to new data if self . normalize is True : X = self . scaler_ . transform ( X ) neighbor_dist , neighbor_ids = self . knn . kneighbors ( X = X ) # mask zero distances neighbor_dist = np . ma . masked_equal ( neighbor_dist , 0 ) # get values of closest training points to new data neighbor_vals = np . array ([ self . y_ [ i ] for i in neighbor_ids ]) # mask neighbor values with zero distances mask = neighbor_dist . mask if mask . all () == False : mask = np . zeros ( neighbor_dist . shape , dtype = np . bool ) mask [:] = False if neighbor_vals . ndim == 2 : neighbor_vals = np . ma . masked_array ( neighbor_vals , mask ) else : n_outputs = neighbor_vals . shape [ 2 ] mask = np . repeat ( mask [:, :, np . newaxis ], n_outputs , axis = 2 ) neighbor_vals = np . ma . masked_array ( neighbor_vals , mask = mask ) # calculated weighted means if self . weights == \"distance\" : new_X = self . _distance_weighting ( neighbor_vals , neighbor_dist ) elif self . weights == \"uniform\" : new_X = self . _uniform_weighting ( neighbor_vals ) elif callable ( self . weights ): new_X = self . _custom_weighting ( neighbor_vals , neighbor_dist ) return np . column_stack (( X , new_X )) def _apply_weights ( self , neighbor_vals , neighbor_weights ): # weighted mean/mode of neighbors for a single regression target if neighbor_vals . ndim == 2 : if self . measure == \"mean\" : X = np . ma . average ( neighbor_vals , weights = neighbor_weights , axis = 1 ) else : X , _ = weighted_mode ( neighbor_vals , neighbor_weights , axis = 1 ) # weighted mean of neighbors for a multi-target regression # neighbor_vals = (n_samples, n_neighbors, n_targets) else : X = np . zeros (( neighbor_vals . shape [ 0 ], neighbor_vals . shape [ 2 ])) if self . measure == \"mean\" : for i in range ( neighbor_vals . shape [ - 1 ]): X [:, i ] = np . ma . average ( neighbor_vals [:, :, i ], weights = neighbor_weights , axis = 1 ) else : for i in range ( neighbor_vals . shape [ - 1 ]): X [:, i ], _ = weighted_mode ( neighbor_vals [:, :, i ], neighbor_weights , axis = 1 ) return X def _distance_weighting ( self , neighbor_vals , neighbor_dist ): weights = 1 / neighbor_dist return self . _apply_weights ( neighbor_vals , weights ) def _uniform_weighting ( self , neighbor_vals ): weights = np . ones (( neighbor_vals . shape [ 0 ], neighbor_vals . shape [ 0 ])) return self . _apply_weights ( neighbor_vals , weights ) def _custom_weighting ( self , neighbor_vals , neighbor_dist ): weights = self . weights ( neighbor_dist , ** self . kernel_params ) return self . _apply_weights ( neighbor_vals , weights ) def _distance_weighting ( self , neighbor_vals , neighbor_dist ): weights = 1 / neighbor_dist return self . _apply_weights ( neighbor_vals , weights ) def _uniform_weighting ( self , neighbor_vals ): weights = np . ones (( neighbor_vals . shape [ 0 ], neighbor_vals . shape [ 0 ])) return self . _apply_weights ( neighbor_vals , weights ) def _custom_weighting ( self , neighbor_vals , neighbor_dist ): weights = self . weights ( neighbor_dist , ** self . kernel_params ) return self . _apply_weights ( neighbor_vals , weights ) fit ( X , y = None ) Fit the base_estimator with features from X {n_samples, n_features} and with an additional spatially lagged variable added to the right-most column of the training data. During fitting, the k-neighbors to each training point are used to estimate the spatial lag component. The training point is not included in the calculation, i.e. the training point is not considered its own neighbor. Parameters array-like of sample {n_samples, n_features} using for model fitting The training input samples array-like of shape (n_samples,) The target values (class labels in classification, real numbers in regression). Source code in pyspatialml/transformers.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def fit ( self , X , y = None ): \"\"\"Fit the base_estimator with features from X {n_samples, n_features} and with an additional spatially lagged variable added to the right-most column of the training data. During fitting, the k-neighbors to each training point are used to estimate the spatial lag component. The training point is not included in the calculation, i.e. the training point is not considered its own neighbor. Parameters ---------- X : array-like of sample {n_samples, n_features} using for model fitting The training input samples y : array-like of shape (n_samples,) The target values (class labels in classification, real numbers in regression). \"\"\" # some checks if self . kernel_params is None : self . kernel_params = {} if y . ndim == 1 : self . n_outputs_ = 1 else : self . n_outputs_ = y . shape [ 1 ] # fit knn and get values of neighbors if self . normalize is True : scaler = Normalizer () X = scaler . fit_transform ( X ) self . scaler_ = scaler self . knn . fit ( X ) self . y_ = y . copy () return self transform ( X , y = None ) Transform method for spatial lag models. Augments new observations with a spatial lag variable created from a weighted mean/mode (regression/classification) of k-neighboring observations. Parameters array-like of sample {n_samples, n_features} New samples for the prediction. None Not used. Source code in pyspatialml/transformers.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def transform ( self , X , y = None ): \"\"\"Transform method for spatial lag models. Augments new observations with a spatial lag variable created from a weighted mean/mode (regression/classification) of k-neighboring observations. Parameters ---------- X : array-like of sample {n_samples, n_features} New samples for the prediction. y : None Not used. \"\"\" # get distances from training points to new data if self . normalize is True : X = self . scaler_ . transform ( X ) neighbor_dist , neighbor_ids = self . knn . kneighbors ( X = X ) # mask zero distances neighbor_dist = np . ma . masked_equal ( neighbor_dist , 0 ) # get values of closest training points to new data neighbor_vals = np . array ([ self . y_ [ i ] for i in neighbor_ids ]) # mask neighbor values with zero distances mask = neighbor_dist . mask if mask . all () == False : mask = np . zeros ( neighbor_dist . shape , dtype = np . bool ) mask [:] = False if neighbor_vals . ndim == 2 : neighbor_vals = np . ma . masked_array ( neighbor_vals , mask ) else : n_outputs = neighbor_vals . shape [ 2 ] mask = np . repeat ( mask [:, :, np . newaxis ], n_outputs , axis = 2 ) neighbor_vals = np . ma . masked_array ( neighbor_vals , mask = mask ) # calculated weighted means if self . weights == \"distance\" : new_X = self . _distance_weighting ( neighbor_vals , neighbor_dist ) elif self . weights == \"uniform\" : new_X = self . _uniform_weighting ( neighbor_vals ) elif callable ( self . weights ): new_X = self . _custom_weighting ( neighbor_vals , neighbor_dist ) return np . column_stack (( X , new_X )) filter_points ( gdf , min_dist = 0 , remove = 'first' ) Filter points in geodataframe using a minimum distance buffer. Args Geopandas GeoDataFrame Containing point geometries. int or float, optional (default=0) Minimum distance by which to filter out closely spaced points. str, optional (default='first') Optionally choose to remove 'first' occurrences or 'last' occurrences. Returns 2d array-like Numpy array filtered coordinates Source code in pyspatialml/vector.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def filter_points ( gdf , min_dist = 0 , remove = \"first\" ): \"\"\"Filter points in geodataframe using a minimum distance buffer. Args ---- gdf : Geopandas GeoDataFrame Containing point geometries. min_dist : int or float, optional (default=0) Minimum distance by which to filter out closely spaced points. remove : str, optional (default='first') Optionally choose to remove 'first' occurrences or 'last' occurrences. Returns ------- xy : 2d array-like Numpy array filtered coordinates \"\"\" xy = gdf . geometry . bounds . iloc [:, 0 : 2 ] Z = linkage ( xy , \"complete\" ) tree_thres = cut_tree ( Z , height = min_dist ) gdf [ \"tree_thres\" ] = tree_thres if remove == \"first\" : gdf = gdf . groupby ( by = \"tree_thres\" ) . first () elif remove == \"last\" : gdf = gdf . groupby ( by = \"tree_thres\" ) . last () return gdf get_random_point_in_polygon ( poly ) Generates random shapely Point geometry objects within a single shapely Polygon object. Args poly : Shapely Polygon object Returns p : Shapely Point object Source code in pyspatialml/vector.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def get_random_point_in_polygon ( poly ): \"\"\"Generates random shapely Point geometry objects within a single shapely Polygon object. Args ---- poly : Shapely Polygon object Returns ------- p : Shapely Point object \"\"\" ( minx , miny , maxx , maxy ) = poly . bounds while True : p = Point ( random . uniform ( minx , maxx ), random . uniform ( miny , maxy )) if poly . contains ( p ): return p","title":"API reference"},{"location":"api/#reference","text":"","title":"Reference"},{"location":"api/#raster","text":"","title":"Raster"},{"location":"api/#pyspatialml.raster.Raster","text":"Bases: _LocIndexer , RasterStats , RasterPlot Creates a collection of file-based GDAL-supported raster datasets that share a common coordinate reference system and geometry. Raster objects encapsulate RasterLayer objects, which represent single band raster datasets that can physically be represented by either separate single-band raster files, multi-band raster files, or any combination of individual bands from multi-band raster and single-band raster datasets.","title":"Raster"},{"location":"api/#pyspatialml.raster.Raster--attributes","text":"list A list of the raster dataset files that are used in the Raster. This does not have to be the same length as the number of RasterLayers because some files may have multiple bands. dict A dict containing the raster metadata. The dict contains the following keys/values: crs : the crs object transform : the Affine.affine transform object width : width of the Raster in pixels height : height of the Raster in pixels count : number of RasterLayers within the Raster dtype : the numpy datatype that represents lowest common denominator of the different dtypes for all of the layers in the Raster. list A list of the RasterLayer names. tuple The default block_shape in (rows, cols) for reading windows of data in the Raster for out-of-memory processing.","title":"Attributes"},{"location":"api/#pyspatialml.raster.Raster.__init__","text":"Initiate a new Raster object","title":"__init__()"},{"location":"api/#pyspatialml.raster.Raster.__init__--parameters","text":"file path, RasterLayer, rasterio dataset, or a ndarray Initiate a Raster object from any combination of a file path or list of file paths to GDAL-supported raster datasets, RasterLayer objects, or directly from a rasterio dataset or band object that is opened in 'r' or 'rw' mode. A Raster object can also be created directly from a numpy array in [band, rows, cols] order. The additional arguments crs and transform should also be provided to supply spatial coordinate information. rasterio.crs.CRS object (optional, default is None) CRS object containing projection information for data if provided as an array. affine.Affine object (optional, default is None) Affine object containing transform information for data if provided as an array. any number (optional, default is None) Assign a nodata value to the Raster dataset when src is a ndarray. If a nodata value is not specified then it is determined based on the minimum permissible value for the array's data type. str (optional, default None) Path to save new Raster object if created from an array. str (optional, default=None) A GDAL compatible driver to use when initiating a raster from a numpy array. str, default is tempfile.tempdir Path to a directory to store temporary files that are produced during geoprocessing operations. bool, default is False Whether to initiate the Raster from an array and store the data in-memory using Rasterio's in-memory files.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.__init__--returns","text":"pyspatialml.Raster Raster object containing the src layers stacked into a single object.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.aggregate","text":"Aggregates a raster to (usually) a coarser grid cell size.","title":"aggregate()"},{"location":"api/#pyspatialml.raster.Raster.aggregate--parameters","text":"tuple New shape in (rows, cols). str (default 'nearest') Resampling method to use when applying decimated reads when out_shape is specified. Supported methods are: 'average', 'bilinear', 'cubic', 'cubic_spline', 'gauss', 'lanczos', 'max', 'med', 'min', 'mode', 'q1', 'q3'. str (optional, default None) File path to save to cropped raster. If not supplied then the aggregated raster is saved to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Coerce RasterLayers to the specified dtype. If not specified then the new intersected Raster is created using the dtype of the existing Raster dataset, which uses a dtype that can accommodate the data types of all of the individual RasterLayers. any number (optional, default None) Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster's dtype. Note that this does not change the pixel nodata values of the raster, it only changes the metadata of what value represents a nodata pixel. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.aggregate--returns","text":"Raster Raster object aggregated to a new pixel size.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.alter","text":"Apply a fitted scikit-learn transformer to a Raster object. Can be used to transform a raster using methods such as StandardScaler, RobustScaler etc.","title":"alter()"},{"location":"api/#pyspatialml.raster.Raster.alter--parameters","text":"transformer : a sklearn.preprocessing.Transformer object str (optional, default None) Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Optionally specify a GDAL compatible data type when saving to file. If not specified, a data type is set based on the data type of the prediction. any number (optional, default None) Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type. bool (default False) Show progress bar for operation.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.alter--returns","text":"Pyspatialml.Raster object with transformed data.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.append","text":"Method to add new RasterLayers to a Raster object. Note that this modifies the Raster object in-place by default.","title":"append()"},{"location":"api/#pyspatialml.raster.Raster.append--parameters","text":"Raster object, or list of Raster objects Object to append to the Raster. bool (default False) Whether to change the Raster object in-place or leave original and return a new Raster object.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.append--returns","text":"Raster Returned only if in_place is False","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.apply","text":"Apply user-supplied function to a Raster object.","title":"apply()"},{"location":"api/#pyspatialml.raster.Raster.apply--parameters","text":"function Function that takes an numpy array as a single argument. str (optional, default None) Optional path to save calculated Raster object. If not specified then a tempfile is used. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Coerce RasterLayers to the specified dtype. If not specified then the new Raster is created using the dtype of the calculation result. any number (optional, default None) Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster's data type. Note that this changes the values of the pixels that represent nodata pixels. bool (default False) Optionally show progress of transform operations. dict (optional) Optionally pass arguments to the function as a dict or keyword arguments. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.apply--returns","text":"Raster Raster containing the calculated result.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.block_shape","text":"Return the block shape in (height, width) used to read windows from the Raster","title":"block_shape()"},{"location":"api/#pyspatialml.raster.Raster.block_shapes","text":"Generator for windows for optimal reading and writing based on the raster format Windows and returns as a tuple with xoff, yoff, width, height.","title":"block_shapes()"},{"location":"api/#pyspatialml.raster.Raster.block_shapes--parameters","text":"int Height of window in rows. int Width of window in columns.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.bounds","text":"Return the bounding box of the raster in (left, bottom, right, top)","title":"bounds()"},{"location":"api/#pyspatialml.raster.Raster.close","text":"Close all of the RasterLayer objects in the Raster. Note that this will cause any rasters based on temporary files to be removed. This is intended as a method of clearing temporary files that may have accumulated during an analysis session.","title":"close()"},{"location":"api/#pyspatialml.raster.Raster.copy","text":"Creates a shallow copy of a Raster object Note that shallow in the context of a Raster object means that an immutable copy of the object is made, however the on-disk and in-memory file locations remain the same.","title":"copy()"},{"location":"api/#pyspatialml.raster.Raster.copy--parameters","text":"opt A list of layer names to subset while copying.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.copy--returns","text":"Raster","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.count","text":"Return the number of layers in the Raster","title":"count()"},{"location":"api/#pyspatialml.raster.Raster.crop","text":"Crops a Raster object by the supplied bounds.","title":"crop()"},{"location":"api/#pyspatialml.raster.Raster.crop--parameters","text":"tuple A tuple containing the bounding box to clip by in the form of (xmin, ymin, xmax, ymax). str (optional, default None) File path to save to cropped raster. If not supplied then the cropped raster is saved to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff'). Default is 'GTiff' Named of GDAL-supported driver for file export. str (optional, default None) Coerce RasterLayers to the specified dtype. If not specified then the new intersected Raster is created using the dtype of theexisting Raster dataset, which uses a dtype that can accommodate the data types of all of the individual RasterLayers. any number (optional, default None) Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster's data type. Note that this does not change the pixel nodata values of the raster, it only changes the metadata of what value represents a nodata pixel. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.crop--returns","text":"Raster Raster cropped to new extent.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.crs","text":"Return to crs of the Raster","title":"crs()"},{"location":"api/#pyspatialml.raster.Raster.drop","text":"Drop individual RasterLayers from a Raster object Note that this modifies the Raster object in-place by default.","title":"drop()"},{"location":"api/#pyspatialml.raster.Raster.drop--parameters","text":"single label or list-like Index (int) or layer name to drop. Can be a single integer or label, or a list of integers or labels. bool (default False) Whether to change the Raster object in-place or leave original and return a new Raster object.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.drop--returns","text":"pyspatialml.Raster Returned only if in_place is True","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.dtypes","text":"Return the dtype of each layer in the Raster as a list","title":"dtypes()"},{"location":"api/#pyspatialml.raster.Raster.extract_raster","text":"Sample a Raster object by an aligned raster of labelled pixels.","title":"extract_raster()"},{"location":"api/#pyspatialml.raster.Raster.extract_raster--parameters","text":"rasterio DatasetReader Single band raster containing labelled pixels as an open rasterio DatasetReader object. bool (opt), default=False Show a progress bar for extraction.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.extract_raster--returns","text":"geopandas.GeoDataFrame Geodataframe containing extracted data as point features if return_array=False","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.extract_vector","text":"Sample a Raster/RasterLayer using a geopandas GeoDataframe containing points, lines or polygon features.","title":"extract_vector()"},{"location":"api/#pyspatialml.raster.Raster.extract_vector--parameters","text":"geopandas.GeoDataFrame Containing either point, line or polygon geometries. Overlapping geometries will cause the same pixels to be sampled. bool (opt), default=False Show a progress bar for extraction.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.extract_vector--returns","text":"geopandas.GeoDataframe Containing extracted data as point geometries (one point per pixel). The resulting GeoDataFrame is indexed using a named pandas.MultiIndex, with pixel_idx index referring to the index of each pixel that was sampled, and the geometry_idx index referring to the index of the each geometry in the supplied gdf . This makes it possible to keep track of how sampled pixel relates to the original geometries, i.e. multiple pixels being extracted within the area of a single polygon that can be referred to using the geometry_idx . The extracted data can subsequently be joined with the attribute table of the supplied `gdf` using: training_py = geopandas.read_file(nc.polygons) df = self.stack.extract_vector(gdf=training_py) df = df.dropna() df = df.merge( right=training_py.loc[:, (\"id\", \"label\")], left_on=\"polygon_idx\", right_on=\"id\", right_index=True )","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.extract_xy","text":"Samples pixel values using an array of xy locations.","title":"extract_xy()"},{"location":"api/#pyspatialml.raster.Raster.extract_xy--parameters","text":"2d array-like x and y coordinates from which to sample the raster (n_samples, xys). bool (opt), default=False By default the extracted pixel values are returned as a geopandas.GeoDataFrame. If return_array=True then the extracted pixel values are returned as a tuple of numpy.ndarrays. bool (opt), default=False Show a progress bar for extraction.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.extract_xy--returns","text":"geopandas.GeoDataframe Containing extracted data as point geometries if return_array=False . numpy.ndarray 2d masked array containing sampled raster values (sample, bands) at the x,y locations.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.head","text":"Return the first 10 rows from the Raster as a ndarray","title":"head()"},{"location":"api/#pyspatialml.raster.Raster.height","text":"Return the height (number of rows) in the Raster","title":"height()"},{"location":"api/#pyspatialml.raster.Raster.intersect","text":"Perform a intersect operation on the Raster object. Computes the geometric intersection of the RasterLayers with the Raster object. This will cause nodata values in any of the rasters to be propagated through all of the output rasters.","title":"intersect()"},{"location":"api/#pyspatialml.raster.Raster.intersect--parameters","text":"str (optional, default None) File path to save to resulting Raster. If not supplied then the resulting Raster is saved to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Coerce RasterLayers to the specified dtype. If not specified then the new intersected Raster is created using the dtype of the existing Raster dataset, which uses a dtype that can accommodate the data types of all of the individual RasterLayers. any number (optional, default None) Nodata value for new dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster's data type. Note that this changes the values of the pixels that represent nodata to the new value. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.intersect--returns","text":"Raster Raster with layers that are masked based on a union of all masks in the suite of RasterLayers.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.mask","text":"Mask a Raster object based on the outline of shapes in a geopandas.GeoDataFrame","title":"mask()"},{"location":"api/#pyspatialml.raster.Raster.mask--parameters","text":"geopandas.GeoDataFrame GeoDataFrame containing masking features. bool (default False) If False then pixels outside shapes will be masked. If True then pixels inside shape will be masked. bool (default True) Crop the raster to the extent of the shapes. bool (default False) If True, the features will be padded in each direction by one half of a pixel prior to cropping raster. str (optional, default None) File path to save to resulting Raster. If not supplied then the resulting Raster is saved to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Coerce RasterLayers to the specified dtype. If not specified then the cropped Raster is created using the existing dtype, which usesa dtype that can accommodate the data types of all of the individual RasterLayers. any number (optional, default None) Nodata value for cropped dataset. If not specified then a nodata value is set based on the minimum permissible value of the Raster's data type. Note that this changes the values of the pixels to the new nodata value, and changes the metadata of the raster. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.mask--returns","text":"pyspatialml.Raster Raster with masked layers.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.nodatavals","text":"Return the nodata value of each layer in the Raster as a list","title":"nodatavals()"},{"location":"api/#pyspatialml.raster.Raster.predict","text":"Apply prediction of a scikit learn model to a Raster. The model can represent any scikit learn model or compatible api with a fit and predict method. These can consist of classification or regression models. Multi-class classifications and multi-target regressions are also supported.","title":"predict()"},{"location":"api/#pyspatialml.raster.Raster.predict--parameters","text":"estimator object implementing 'fit' The object to use to fit the data. str (optional, default None) Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export str (optional, default None) Optionally specify a GDAL compatible data type when saving to file. If not specified, np.float32 is assumed. any number (optional, default None) Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type. bool (default False) Show progress bar for prediction. list-like object or a dict (optional, default None) Constant features to add to the Raster object with each value in a list or 1d ndarray representing an additional feature. If a list-like object of values os passed, then each numeric value will be appended as constant features to the last columns in the data. It is therefore important that all features including constant features are present in the same order as what was used to train the model. If a dict is passed, then the keys of the dict must refer to the names of raster layers in the Raster object. In this case, the values of the dict will replace the values of the raster layers in the Raster object. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.predict--returns","text":"Raster Raster object containing prediction results as a RasterLayers. For classification and regression models, the Raster will contain a single RasterLayer, unless the model is multi-class or multi-target. Layers are named automatically as pred_raw_n with n = 1, 2, 3 ..n.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.predict_proba","text":"Apply class probability prediction of a scikit learn model to a Raster.","title":"predict_proba()"},{"location":"api/#pyspatialml.raster.Raster.predict_proba--parameters","text":"estimator object implementing 'fit' The object to use to fit the data. str (optional, default None) Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. list of integers (optional, default None) List of class indices to export. In some circumstances, only a subset of the class probability estimations are desired, for instance when performing a binary classification only the probabilities for the positive class may be desired. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Optionally specify a GDAL compatible data type when saving to file. If not specified, a data type is set based on the data type of the prediction. any number (optional, default None) Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type. bool (default False) Show progress bar for prediction. list-like object or a dict (optional, default None) Constant features to add to the Raster object with each value in a list or 1d ndarray representing an additional feature. If a list-like object of values os passed, then each numeric value will be appended as constant features to the last columns in the data. It is therefore important that all features including constant features are present in the same order as what was used to train the model. If a dict is passed, then the keys of the dict must refer to the names of raster layers in the Raster object. In this case, the values of the dict will replace the values of the raster layers in the Raster object. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.predict_proba--returns","text":"Raster Raster containing predicted class probabilities. Each predicted class is represented by a RasterLayer object. The RasterLayers are named prob_n for 1,2,3..n, with n based on the index position of the classes, not the number of the class itself. For example, a classification model predicting classes with integer values of 1, 3, and 5 would result in three RasterLayers named 'prob_1', 'prob_2' and 'prob_3'.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.read","text":"Reads data from the Raster object into a numpy array.","title":"read()"},{"location":"api/#pyspatialml.raster.Raster.read--parameters","text":"bool (default False) Read data into a masked array. rasterio.window.Window object (optional, default None) Tuple of col_off, row_off, width, height of a window of data to read a chunk of data into a ndarray. tuple (optional, default None) Shape of shape of array (rows, cols) to read data into using decimated reads. str (default 'nearest') Resampling method to use when applying decimated reads when out_shape is specified. Supported methods are: 'average', 'bilinear', 'cubic', 'cubic_spline', 'gauss', 'lanczos', 'max', 'med', 'min', 'mode', 'q1', 'q3'. bool (default False) Whether to return the data as a pandas.DataFrame with columns named by the RasterLayer names. **kwargs : dict Other arguments to pass to rasterio.DatasetReader.read method","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.read--returns","text":"ndarray Raster values in 3d ndarray with the dimensions in order of (band, row, and column).","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.rename","text":"Rename a RasterLayer within the Raster object.","title":"rename()"},{"location":"api/#pyspatialml.raster.Raster.rename--parameters","text":"dict dict of old_name : new_name bool (default False) Whether to change names of the Raster object in-place or leave original and return a new Raster object.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.rename--returns","text":"pyspatialml.Raster Returned only if in_place is False","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.res","text":"Return a tuple of the resolution of the Raster in (width, height)","title":"res()"},{"location":"api/#pyspatialml.raster.Raster.sample","text":"Generates a random sample of according to size, and samples the pixel values.","title":"sample()"},{"location":"api/#pyspatialml.raster.Raster.sample--parameters","text":"int Number of random samples or number of samples per strata if a strata object is supplied. pyspatialml Raster object (opt) Whether to use stratified instead of random sampling. Strata can be supplied using another pyspatialml.Raster object. bool (opt), default=False Optionally return extracted data as separate X and xy masked numpy arrays. int (opt) integer to use within random.seed.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.sample--returns","text":"pandas.DataFrame DataFrame containing values of names of RasterLayers in the Raster if return_array is False. tuple A tuple containing two elements if return_array is True: - numpy.ndarray Numpy array of extracted raster values, typically 2d. - numpy.ndarray 2D numpy array of xy coordinates of extracted values.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.scale","text":"Standardize (centre and scale) a Raster object by subtracting the mean and dividing by the standard deviation for each layer in the object. The mean and standard deviation statistics are calculated for each layer separately.","title":"scale()"},{"location":"api/#pyspatialml.raster.Raster.scale--parameters","text":"bool, default is True Whether to subtract the mean from each layer. bool, default is True Whether to divide each layer by the standard deviation of the layer. str (optional, default None) Path to a GeoTiff raster for the prediction results. If not specified then the output is written to a temporary file. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. str (optional, default None) Optionally specify a GDAL compatible data type when saving to file. If not specified, a data type is set based on the data type of the prediction. any number (optional, default None) Nodata value for file export. If not specified then the nodata value is derived from the minimum permissible value for the given data type. bool (default False) Show progress bar for operation.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.scale--returns","text":"Pyspatialml.Raster object with rescaled data.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.set_block_shape","text":"Set the block shape of the raster, i.e. the height and width of windows to read in chunks for the predict, predict_proba, apply, and other supported-methods. Note block shape can also be set with myraster.block_shape = (500, 500)","title":"set_block_shape()"},{"location":"api/#pyspatialml.raster.Raster.set_block_shape--parameters","text":"tuple A tuple of (height, width) for the block window","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.shape","text":"Return the shape (height, width) of the Raster","title":"shape()"},{"location":"api/#pyspatialml.raster.Raster.tail","text":"Return the last 10 rows from the Raster as a ndarray","title":"tail()"},{"location":"api/#pyspatialml.raster.Raster.to_crs","text":"Reprojects a Raster object to a different crs.","title":"to_crs()"},{"location":"api/#pyspatialml.raster.Raster.to_crs--parameters","text":"rasterio.transform.CRS object, or dict Example: CRS({'init': 'EPSG:4326'}) str (default 'nearest') Resampling method to use. One of the following: nearest, bilinear, cubic, cubic_spline, lanczos, average, mode, max (GDAL >= 2.2), min (GDAL >= 2.2), med (GDAL >= 2.2), q1 (GDAL >= 2.2), q3 (GDAL >= 2.2) str (optional, default None) Optional path to save reprojected Raster object. If not specified then a tempfile is used. bool, default is False Whether to initiated the Raster from an array and store the data in-memory using Rasterio's in-memory files. str (default 'GTiff') Named of GDAL-supported driver for file export. any number (optional, default None) Nodata value for new dataset. If not specified then the existing nodata value of the Raster object is used, which can accommodate the dtypes of the individual layers in the Raster. int (default 1) The number of warp worker threads. int (default 0) The warp operation memory limit in MB. Larger values allow the warp operation to be carried out in fewer chunks. The amount of memory required to warp a 3-band uint8 2000 row x 2000 col raster to a destination of the same size is approximately 56 MB. The default (0) means 64 MB with GDAL 2.2. bool (default False) Optionally show progress of transform operations. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.to_crs--returns","text":"Raster Raster following reprojection.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.to_pandas","text":"Raster to pandas DataFrame.","title":"to_pandas()"},{"location":"api/#pyspatialml.raster.Raster.to_pandas--parameters","text":"int (default None) Maximum number of pixels to sample. By default all pixels are used. str (default 'nearest') Resampling method to use when applying decimated reads when out_shape is specified. Supported methods are: 'average', 'bilinear', 'cubic', 'cubic_spline', 'gauss', 'lanczos', 'max', 'med', 'min', 'mode', 'q1', 'q3'.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.to_pandas--returns","text":"pandas.DataFrame DataFrame containing values of names of RasterLayers in the Raster as columns, and pixel values as rows.","title":"Returns"},{"location":"api/#pyspatialml.raster.Raster.transform","text":"Return the transform of the Raster","title":"transform()"},{"location":"api/#pyspatialml.raster.Raster.width","text":"Return the width (number of columns) in the Raster","title":"width()"},{"location":"api/#pyspatialml.raster.Raster.write","text":"Write the Raster object to a file. Overrides the write RasterBase class method, which is a partial function of the rasterio.DatasetReader.write method.","title":"write()"},{"location":"api/#pyspatialml.raster.Raster.write--parameters","text":"str File path used to save the Raster object. str (default is 'GTiff'). Name of GDAL driver used to save Raster data. str (opt, default None) Optionally specify a numpy compatible data type when saving to file. If not specified, a data type is selected based on the data types of RasterLayers in the Raster object. any number (opt, default None) Optionally assign a new nodata value when saving to file. If not specified a nodata value based on the minimum permissible value for the data types of RasterLayers in the Raster object is used. Note that this does not change the pixel nodata values of the raster, it only changes the metadata of what value represents a nodata pixel. opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression.","title":"Parameters"},{"location":"api/#pyspatialml.raster.Raster.write--returns","text":"Raster New Raster object from saved file.","title":"Returns"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer","text":"Represents a single raster band derived from a single or multi-band raster dataset Simple wrapper around a rasterio.Band object with additional methods. Used because the Rasterio.Band.ds.read method reads all bands from a multi-band dataset, whereas the RasterLayer read method only reads a single band. Methods encapsulated in RasterLayer objects represent those that typically would only be applied to a single-band of a raster, i.e. sieve-clump, distance to non-NaN pixels, or arithmetic operations on individual layers.","title":"RasterLayer"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer--attributes","text":"int The band index of the RasterLayer within the file dataset. str The data type of the RasterLayer. rasterio.band The underlying rasterio.band object. str A syntactically valid name for the RasterLayer. str The file path to the dataset. any number The number that is used to represent nodata pixels in the RasterLayer. str The name of the GDAL format driver. dict A python dict storing the RasterLayer metadata. affine.Affine object The affine transform parameters. int Number of layers; always equal to 1. tuple Shape of RasterLayer in (rows, columns) width, height: int The width (cols) and height (rows) of the dataset. BoundingBox named tuple A named tuple with left, bottom, right and top coordinates of the dataset. str The name of matplotlib map, or a custom matplotlib.cm.LinearSegmentedColormap or ListedColormap object. matplotlib.colors.Normalize (opt) A matplotlib.colors.Normalize to apply to the RasterLayer. This overides the norm attribute of the RasterLayer. Source code in pyspatialml/rasterlayer.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 class RasterLayer : \"\"\"Represents a single raster band derived from a single or multi-band raster dataset Simple wrapper around a rasterio.Band object with additional methods. Used because the Rasterio.Band.ds.read method reads all bands from a multi-band dataset, whereas the RasterLayer read method only reads a single band. Methods encapsulated in RasterLayer objects represent those that typically would only be applied to a single-band of a raster, i.e. sieve-clump, distance to non-NaN pixels, or arithmetic operations on individual layers. Attributes ---------- bidx : int The band index of the RasterLayer within the file dataset. dtype : str The data type of the RasterLayer. ds : rasterio.band The underlying rasterio.band object. name : str A syntactically valid name for the RasterLayer. file : str The file path to the dataset. nodata : any number The number that is used to represent nodata pixels in the RasterLayer. driver : str The name of the GDAL format driver. meta : dict A python dict storing the RasterLayer metadata. transform : affine.Affine object The affine transform parameters. count : int Number of layers; always equal to 1. shape: tuple Shape of RasterLayer in (rows, columns) width, height: int The width (cols) and height (rows) of the dataset. bounds : BoundingBox named tuple A named tuple with left, bottom, right and top coordinates of the dataset. cmap : str The name of matplotlib map, or a custom matplotlib.cm.LinearSegmentedColormap or ListedColormap object. norm : matplotlib.colors.Normalize (opt) A matplotlib.colors.Normalize to apply to the RasterLayer. This overides the norm attribute of the RasterLayer. \"\"\" def __init__ ( self , band ): \"\"\"Initiate a RasterLayer object Parameters ---------- band : a rasterio.Band object \"\"\" self . bidx = band . bidx self . dtype = band . dtype self . ds = band . ds if len ( band . ds . files ) > 0 : self . name = _make_name ( band . ds . files [ 0 ]) self . file = band . ds . files [ 0 ] else : self . name = \"in_memory\" self . file = None self . nodata = band . ds . nodata self . driver = band . ds . meta [ \"driver\" ] self . meta = band . ds . meta self . transform = band . ds . transform self . crs = band . ds . crs self . count = 1 self . shape = band . shape self . width = band . ds . width self . height = band . ds . height self . bounds = band . ds . bounds self . in_memory = False self . cmap = \"viridis\" self . norm = None self . categorical = False def close ( self ): self . ds . close () def _arith ( self , function , other = None ): \"\"\"General method for performing arithmetic operations on RasterLayer objects Parameters ---------- function : function Custom function that takes either one or two arrays, and returns a single array following a pre-defined calculation. other : pyspatialml.RasterLayer (optional, default None) If not specified, then a `function` should be provided that performs a calculation using only the selected RasterLayer. If `other` is specified, then a `function` should be supplied that takes to ndarrays as arguments and performs a calculation using both layers, i.e. layer1 - layer2. Returns ------- pyspatialml.RasterLayer Returns a single RasterLayer containing the calculated result. \"\"\" driver = self . driver if isinstance ( other , RasterLayer ): result = function ( self . read ( masked = True ), other . read ( masked = True )) else : result = function ( self . read ( masked = True )) nodata = get_nodata_value ( result . dtype ) # open output file with updated metadata meta = self . meta . copy () meta . update ( driver = driver , count = 1 , dtype = result . dtype , nodata = nodata ) with MemoryFile () as memfile : dst = memfile . open ( ** meta ) result = np . ma . filled ( result , fill_value = nodata ) dst . write ( result , indexes = 1 ) # create RasterLayer from result layer = RasterLayer ( rasterio . band ( dst , 1 )) return layer def __add__ ( self , other ): \"\"\"Implements behaviour for addition of two RasterLayers, i.e. added_layer = layer1 + layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 + arr2 return self . _arith ( func , other ) def __sub__ ( self , other ): \"\"\"Implements behaviour for subtraction of two RasterLayers, i.e. subtracted_layer = layer1 - layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 - arr2 return self . _arith ( func , other ) def __mul__ ( self , other ): \"\"\"Implements behaviour for multiplication of two RasterLayers, i.e. product = layer1 * layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 * arr2 return self . _arith ( func , other ) def __truediv__ ( self , other ): \"\"\"Implements behaviour for division using `/` of two RasterLayers, i.e. div = layer1 / layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 / arr2 return self . _arith ( func , other ) def __and__ ( self , other ): \"\"\"Implements & operator Equivalent to a intersection operation of self with other, i.e. intersected = layer1 & layer2. \"\"\" def func ( arr1 , arr2 ): mask = np . logical_and ( arr1 , arr2 ) . mask arr1 . mask [ mask ] = True return arr1 return self . _arith ( func , other ) def __or__ ( self , other ): \"\"\"Implements | operator Fills gaps in self with pixels from other. Equivalent to a union operation, i.e. union = layer1 | layer2. \"\"\" def func ( arr1 , arr2 ): idx = np . logical_or ( arr1 , arr2 . mask ) . mask arr1 [ idx ] = arr2 [ idx ] return arr1 return self . _arith ( func , other ) def __xor__ ( self , other ): \"\"\"Exclusive OR using ^ Equivalent to a symmetrical difference where the result comprises pixels that occur in self or other, but not both, i.e. xor = layer1 ^ layer2. \"\"\" def func ( arr1 , arr2 ): mask = ~ np . logical_xor ( arr1 , arr2 ) idx = np . logical_or ( arr1 , arr2 . mask ) . mask arr1 [ idx ] = arr2 [ idx ] arr1 . mask [ np . nonzero ( mask )] = True return arr1 return self . _arith ( func , other ) def __round__ ( self , ndigits ): \"\"\"Behaviour for round() function, i.e. round(layer)\"\"\" def func ( arr , ndigits ): return np . round ( arr , ndigits ) func = partial ( func , ndigits = ndigits ) return self . _arith ( func ) def __floor__ ( self ): \"\"\"Rounding down to the nearest integer using math.floor(), i.e. math.floor(layer)\"\"\" def func ( arr ): return np . floor ( arr ) return self . _arith ( func ) def __ceil__ ( self ): \"\"\"Rounding up to the nearest integer using math.ceil(), i.e. math.ceil(layer)\"\"\" def func ( arr ): return np . ceil ( arr ) return self . _arith ( func ) def __trunc__ ( self ): \"\"\"Truncating to an integral using math.trunc(), i.e. math.trunc(layer)\"\"\" def func ( arr ): return np . trunc ( arr ) return self . _arith ( func ) def __abs__ ( self ): \"\"\"abs() function as applied to a RasterLayer, i.e. abs(layer)\"\"\" def func ( arr ): return np . abs ( arr ) return self . _arith ( func ) def __pos__ ( self ): \"\"\"Unary positive, i.e. +layer1\"\"\" def func ( arr ): return np . positive ( arr ) return self . _arith ( func ) def __neg__ ( self ): \"\"\" Unary negative, i.e. -layer1 \"\"\" def func ( arr ): return np . negative ( arr ) return self . _arith ( func ) def _stats ( self , max_pixels ): \"\"\"Take a sample of pixels from which to derive per-band statistics.\"\"\" rel_width = self . shape [ 1 ] / max_pixels if rel_width > 1 : col_scaling = round ( max_pixels / rel_width ) row_scaling = max_pixels - col_scaling else : col_scaling = round ( max_pixels * rel_width ) row_scaling = max_pixels - col_scaling out_shape = ( row_scaling , col_scaling ) arr = self . read ( masked = True , out_shape = out_shape ) arr = arr . flatten () return arr def min ( self , max_pixels = 10000 ): \"\"\"Minimum value. Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The minimum value of the object \"\"\" arr = self . _stats ( max_pixels ) return np . nanmin ( arr ) def max ( self , max_pixels = 10000 ): \"\"\"Maximum value. Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The maximum value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmax ( arr ) def mean ( self , max_pixels = 10000 ): \"\"\"Mean value Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The mean value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmean ( arr ) def median ( self , max_pixels = 10000 ): \"\"\"Median value Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The medium value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmedian ( arr ) def stddev ( self , max_pixels = 10000 ): \"\"\"Standard deviation Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The standard deviation of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanstd ( arr ) def read ( self , ** kwargs ): \"\"\"Read method for a single RasterLayer. Reads the pixel values from a RasterLayer into a ndarray that always will have two dimensions in the order of (rows, columns). Parameters ---------- **kwargs : named arguments that can be passed to the the rasterio.DatasetReader.read method. \"\"\" if \"resampling\" in kwargs . keys (): resampling_methods = [ i . name for i in rasterio . enums . Resampling ] if kwargs [ \"resampling\" ] not in resampling_methods : raise ValueError ( \"Invalid resampling method. Resampling \" \"method must be one of {0} :\" . format ( resampling_methods ) ) kwargs [ \"resampling\" ] = rasterio . enums . Resampling [ kwargs [ \"resampling\" ]] return self . ds . read ( indexes = self . bidx , ** kwargs ) def write ( self , file_path , driver = \"GTiff\" , dtype = None , nodata = None , ** kwargs ): \"\"\"Write method for a single RasterLayer. Parameters ---------- file_path : str (opt) File path to save the dataset. driver : str GDAL-compatible driver used for the file format. dtype : str (opt) Numpy dtype used for the file. If omitted then the RasterLayer's dtype is used. nodata : any number (opt) A value used to represent the nodata pixels. If omitted then the RasterLayer's nodata value is used (if assigned already). kwargs : opt Optional named arguments to pass to the format drivers. For example can be `compress=\"deflate\"` to add compression. Returns ------- pyspatialml.RasterLayer \"\"\" if dtype is None : dtype = self . dtype if nodata is None : nodata = get_nodata_value ( dtype ) meta = self . ds . meta meta [ \"driver\" ] = driver meta [ \"nodata\" ] = nodata meta [ \"dtype\" ] = dtype meta . update ( kwargs ) # mask any nodata values arr = np . ma . masked_equal ( self . read (), self . nodata ) arr = arr . filled ( fill_value = nodata ) # write to file with rasterio . open ( file_path , mode = \"w\" , ** meta ) as dst : dst . write ( arr . astype ( dtype ), 1 ) src = rasterio . open ( file_path ) band = rasterio . band ( src , 1 ) layer = RasterLayer ( band ) return layer def _extract_by_indices ( self , rows , cols ): \"\"\"Spatial query of Raster object (by-band)\"\"\" X = np . ma . zeros (( len ( rows ), self . count ), dtype = \"float32\" ) arr = self . read ( masked = True ) X [:, 0 ] = arr [ rows , cols ] return X def plot ( self , cmap = None , norm = None , ax = None , cax = None , figsize = None , out_shape = ( 500 , 500 ), categorical = None , legend = False , vmin = None , vmax = None , fig_kwds = None , legend_kwds = None , ): \"\"\"Plot a RasterLayer using matplotlib.pyplot.imshow Parameters ---------- cmap : str (default None) The name of a colormap recognized by matplotlib. Overrides the cmap attribute of the RasterLayer. norm : matplotlib.colors.Normalize (opt) A matplotlib.colors.Normalize to apply to the RasterLayer. This overrides the norm attribute of the RasterLayer. ax : matplotlib.pyplot.Artist (optional, default None) axes instance on which to draw to plot. cax : matplotlib.pyplot.Artist (optional, default None) axes on which to draw the legend. figsize : tuple of integers (optional, default None) Size of the matplotlib.figure.Figure. If the ax argument is given explicitly, figsize is ignored. out_shape : tuple, default=(500, 500) Number of rows, cols to read from the raster datasets for plotting. categorical : bool (optional, default False) if True then the raster values will be considered to represent discrete values, otherwise they are considered to represent continuous values. This overrides the RasterLayer 'categorical' attribute. Setting the argument categorical to True is ignored if the RasterLayer.categorical is already True. legend : bool (optional, default False) Whether to plot the legend. vmin, xmax : scale (optional, default None) vmin and vmax define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. vmin, vmax are ignored if the norm parameter is used. fig_kwds : dict (optional, default None) Additional arguments to pass to the matplotlib.pyplot.figure call when creating the figure object. Ignored if ax is passed to the plot function. legend_kwds : dict (optional, default None) Keyword arguments to pass to matplotlib.pyplot.colorbar(). Returns ------- ax : matplotlib axes instance \"\"\" # some checks if fig_kwds is None : fig_kwds = {} if ax is None : if cax is not None : raise ValueError ( \"'ax' can not be None if 'cax' is not.\" ) fig , ax = plt . subplots ( figsize = figsize , ** fig_kwds ) ax . set_aspect ( \"equal\" ) if norm : if not isinstance ( norm , mpl . colors . Normalize ): raise AttributeError ( \"norm argument should be a \" \"matplotlib.colors.Normalize object\" ) if cmap is None : cmap = self . cmap if norm is None : norm = self . norm if legend_kwds is None : legend_kwds = {} arr = self . read ( masked = True , out_shape = out_shape ) if categorical is True : if self . categorical is False : N = np . bincount ( arr ) cmap = discrete_cmap ( N , base_cmap = cmap ) vmin , vmax = None , None im = ax . imshow ( X = arr , extent = rasterio . plot . plotting_extent ( self . ds ), cmap = cmap , norm = norm , vmin = vmin , vmax = vmax , ) if legend is True : plt . colorbar ( im , cax = cax , ax = ax , ** legend_kwds ) return ax","title":"Attributes"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__abs__","text":"abs() function as applied to a RasterLayer, i.e. abs(layer) Source code in pyspatialml/rasterlayer.py 285 286 287 288 289 290 291 def __abs__ ( self ): \"\"\"abs() function as applied to a RasterLayer, i.e. abs(layer)\"\"\" def func ( arr ): return np . abs ( arr ) return self . _arith ( func )","title":"__abs__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__add__","text":"Implements behaviour for addition of two RasterLayers, i.e. added_layer = layer1 + layer2 Source code in pyspatialml/rasterlayer.py 163 164 165 166 167 168 169 170 171 def __add__ ( self , other ): \"\"\"Implements behaviour for addition of two RasterLayers, i.e. added_layer = layer1 + layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 + arr2 return self . _arith ( func , other )","title":"__add__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__and__","text":"Implements & operator Equivalent to a intersection operation of self with other, i.e. intersected = layer1 & layer2. Source code in pyspatialml/rasterlayer.py 203 204 205 206 207 208 209 210 211 212 213 214 215 def __and__ ( self , other ): \"\"\"Implements & operator Equivalent to a intersection operation of self with other, i.e. intersected = layer1 & layer2. \"\"\" def func ( arr1 , arr2 ): mask = np . logical_and ( arr1 , arr2 ) . mask arr1 . mask [ mask ] = True return arr1 return self . _arith ( func , other )","title":"__and__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__ceil__","text":"Rounding up to the nearest integer using math.ceil(), i.e. math.ceil(layer) Source code in pyspatialml/rasterlayer.py 267 268 269 270 271 272 273 274 def __ceil__ ( self ): \"\"\"Rounding up to the nearest integer using math.ceil(), i.e. math.ceil(layer)\"\"\" def func ( arr ): return np . ceil ( arr ) return self . _arith ( func )","title":"__ceil__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__floor__","text":"Rounding down to the nearest integer using math.floor(), i.e. math.floor(layer) Source code in pyspatialml/rasterlayer.py 258 259 260 261 262 263 264 265 def __floor__ ( self ): \"\"\"Rounding down to the nearest integer using math.floor(), i.e. math.floor(layer)\"\"\" def func ( arr ): return np . floor ( arr ) return self . _arith ( func )","title":"__floor__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__init__","text":"Initiate a RasterLayer object","title":"__init__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__init__--parameters","text":"band : a rasterio.Band object Source code in pyspatialml/rasterlayer.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __init__ ( self , band ): \"\"\"Initiate a RasterLayer object Parameters ---------- band : a rasterio.Band object \"\"\" self . bidx = band . bidx self . dtype = band . dtype self . ds = band . ds if len ( band . ds . files ) > 0 : self . name = _make_name ( band . ds . files [ 0 ]) self . file = band . ds . files [ 0 ] else : self . name = \"in_memory\" self . file = None self . nodata = band . ds . nodata self . driver = band . ds . meta [ \"driver\" ] self . meta = band . ds . meta self . transform = band . ds . transform self . crs = band . ds . crs self . count = 1 self . shape = band . shape self . width = band . ds . width self . height = band . ds . height self . bounds = band . ds . bounds self . in_memory = False self . cmap = \"viridis\" self . norm = None self . categorical = False","title":"Parameters"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__mul__","text":"Implements behaviour for multiplication of two RasterLayers, i.e. product = layer1 * layer2 Source code in pyspatialml/rasterlayer.py 183 184 185 186 187 188 189 190 191 def __mul__ ( self , other ): \"\"\"Implements behaviour for multiplication of two RasterLayers, i.e. product = layer1 * layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 * arr2 return self . _arith ( func , other )","title":"__mul__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__neg__","text":"Unary negative, i.e. -layer1 Source code in pyspatialml/rasterlayer.py 301 302 303 304 305 306 307 308 309 def __neg__ ( self ): \"\"\" Unary negative, i.e. -layer1 \"\"\" def func ( arr ): return np . negative ( arr ) return self . _arith ( func )","title":"__neg__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__or__","text":"Implements | operator Fills gaps in self with pixels from other. Equivalent to a union operation, i.e. union = layer1 | layer2. Source code in pyspatialml/rasterlayer.py 217 218 219 220 221 222 223 224 225 226 227 228 229 def __or__ ( self , other ): \"\"\"Implements | operator Fills gaps in self with pixels from other. Equivalent to a union operation, i.e. union = layer1 | layer2. \"\"\" def func ( arr1 , arr2 ): idx = np . logical_or ( arr1 , arr2 . mask ) . mask arr1 [ idx ] = arr2 [ idx ] return arr1 return self . _arith ( func , other )","title":"__or__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__pos__","text":"Unary positive, i.e. +layer1 Source code in pyspatialml/rasterlayer.py 293 294 295 296 297 298 299 def __pos__ ( self ): \"\"\"Unary positive, i.e. +layer1\"\"\" def func ( arr ): return np . positive ( arr ) return self . _arith ( func )","title":"__pos__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__round__","text":"Behaviour for round() function, i.e. round(layer) Source code in pyspatialml/rasterlayer.py 248 249 250 251 252 253 254 255 256 def __round__ ( self , ndigits ): \"\"\"Behaviour for round() function, i.e. round(layer)\"\"\" def func ( arr , ndigits ): return np . round ( arr , ndigits ) func = partial ( func , ndigits = ndigits ) return self . _arith ( func )","title":"__round__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__sub__","text":"Implements behaviour for subtraction of two RasterLayers, i.e. subtracted_layer = layer1 - layer2 Source code in pyspatialml/rasterlayer.py 173 174 175 176 177 178 179 180 181 def __sub__ ( self , other ): \"\"\"Implements behaviour for subtraction of two RasterLayers, i.e. subtracted_layer = layer1 - layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 - arr2 return self . _arith ( func , other )","title":"__sub__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__truediv__","text":"Implements behaviour for division using / of two RasterLayers, i.e. div = layer1 / layer2 Source code in pyspatialml/rasterlayer.py 193 194 195 196 197 198 199 200 201 def __truediv__ ( self , other ): \"\"\"Implements behaviour for division using `/` of two RasterLayers, i.e. div = layer1 / layer2 \"\"\" def func ( arr1 , arr2 ): return arr1 / arr2 return self . _arith ( func , other )","title":"__truediv__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__trunc__","text":"Truncating to an integral using math.trunc(), i.e. math.trunc(layer) Source code in pyspatialml/rasterlayer.py 276 277 278 279 280 281 282 283 def __trunc__ ( self ): \"\"\"Truncating to an integral using math.trunc(), i.e. math.trunc(layer)\"\"\" def func ( arr ): return np . trunc ( arr ) return self . _arith ( func )","title":"__trunc__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.__xor__","text":"Exclusive OR using ^ Equivalent to a symmetrical difference where the result comprises pixels that occur in self or other, but not both, i.e. xor = layer1 ^ layer2. Source code in pyspatialml/rasterlayer.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def __xor__ ( self , other ): \"\"\"Exclusive OR using ^ Equivalent to a symmetrical difference where the result comprises pixels that occur in self or other, but not both, i.e. xor = layer1 ^ layer2. \"\"\" def func ( arr1 , arr2 ): mask = ~ np . logical_xor ( arr1 , arr2 ) idx = np . logical_or ( arr1 , arr2 . mask ) . mask arr1 [ idx ] = arr2 [ idx ] arr1 . mask [ np . nonzero ( mask )] = True return arr1 return self . _arith ( func , other )","title":"__xor__()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.max","text":"Maximum value.","title":"max()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.max--parameters","text":"int Number of pixels used to inform statistical estimate.","title":"Parameters"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.max--returns","text":"numpy.float32 The maximum value of the object's pixels. Source code in pyspatialml/rasterlayer.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def max ( self , max_pixels = 10000 ): \"\"\"Maximum value. Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The maximum value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmax ( arr )","title":"Returns"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.mean","text":"Mean value","title":"mean()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.mean--parameters","text":"int Number of pixels used to inform statistical estimate.","title":"Parameters"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.mean--returns","text":"numpy.float32 The mean value of the object's pixels. Source code in pyspatialml/rasterlayer.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 def mean ( self , max_pixels = 10000 ): \"\"\"Mean value Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The mean value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmean ( arr )","title":"Returns"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.median","text":"Median value","title":"median()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.median--parameters","text":"int Number of pixels used to inform statistical estimate.","title":"Parameters"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.median--returns","text":"numpy.float32 The medium value of the object's pixels. Source code in pyspatialml/rasterlayer.py 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 def median ( self , max_pixels = 10000 ): \"\"\"Median value Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The medium value of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanmedian ( arr )","title":"Returns"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.min","text":"Minimum value.","title":"min()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.min--parameters","text":"int Number of pixels used to inform statistical estimate.","title":"Parameters"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.min--returns","text":"numpy.float32 The minimum value of the object Source code in pyspatialml/rasterlayer.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 def min ( self , max_pixels = 10000 ): \"\"\"Minimum value. Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The minimum value of the object \"\"\" arr = self . _stats ( max_pixels ) return np . nanmin ( arr )","title":"Returns"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.plot","text":"Plot a RasterLayer using matplotlib.pyplot.imshow Parameters str (default None) The name of a colormap recognized by matplotlib. Overrides the cmap attribute of the RasterLayer. matplotlib.colors.Normalize (opt) A matplotlib.colors.Normalize to apply to the RasterLayer. This overrides the norm attribute of the RasterLayer. matplotlib.pyplot.Artist (optional, default None) axes instance on which to draw to plot. matplotlib.pyplot.Artist (optional, default None) axes on which to draw the legend. tuple of integers (optional, default None) Size of the matplotlib.figure.Figure. If the ax argument is given explicitly, figsize is ignored. tuple, default=(500, 500) Number of rows, cols to read from the raster datasets for plotting. bool (optional, default False) if True then the raster values will be considered to represent discrete values, otherwise they are considered to represent continuous values. This overrides the RasterLayer 'categorical' attribute. Setting the argument categorical to True is ignored if the RasterLayer.categorical is already True. bool (optional, default False) Whether to plot the legend. vmin, xmax : scale (optional, default None) vmin and vmax define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. vmin, vmax are ignored if the norm parameter is used. dict (optional, default None) Additional arguments to pass to the matplotlib.pyplot.figure call when creating the figure object. Ignored if ax is passed to the plot function. dict (optional, default None) Keyword arguments to pass to matplotlib.pyplot.colorbar().","title":"plot()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.plot--returns","text":"ax : matplotlib axes instance Source code in pyspatialml/rasterlayer.py 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 def plot ( self , cmap = None , norm = None , ax = None , cax = None , figsize = None , out_shape = ( 500 , 500 ), categorical = None , legend = False , vmin = None , vmax = None , fig_kwds = None , legend_kwds = None , ): \"\"\"Plot a RasterLayer using matplotlib.pyplot.imshow Parameters ---------- cmap : str (default None) The name of a colormap recognized by matplotlib. Overrides the cmap attribute of the RasterLayer. norm : matplotlib.colors.Normalize (opt) A matplotlib.colors.Normalize to apply to the RasterLayer. This overrides the norm attribute of the RasterLayer. ax : matplotlib.pyplot.Artist (optional, default None) axes instance on which to draw to plot. cax : matplotlib.pyplot.Artist (optional, default None) axes on which to draw the legend. figsize : tuple of integers (optional, default None) Size of the matplotlib.figure.Figure. If the ax argument is given explicitly, figsize is ignored. out_shape : tuple, default=(500, 500) Number of rows, cols to read from the raster datasets for plotting. categorical : bool (optional, default False) if True then the raster values will be considered to represent discrete values, otherwise they are considered to represent continuous values. This overrides the RasterLayer 'categorical' attribute. Setting the argument categorical to True is ignored if the RasterLayer.categorical is already True. legend : bool (optional, default False) Whether to plot the legend. vmin, xmax : scale (optional, default None) vmin and vmax define the data range that the colormap covers. By default, the colormap covers the complete value range of the supplied data. vmin, vmax are ignored if the norm parameter is used. fig_kwds : dict (optional, default None) Additional arguments to pass to the matplotlib.pyplot.figure call when creating the figure object. Ignored if ax is passed to the plot function. legend_kwds : dict (optional, default None) Keyword arguments to pass to matplotlib.pyplot.colorbar(). Returns ------- ax : matplotlib axes instance \"\"\" # some checks if fig_kwds is None : fig_kwds = {} if ax is None : if cax is not None : raise ValueError ( \"'ax' can not be None if 'cax' is not.\" ) fig , ax = plt . subplots ( figsize = figsize , ** fig_kwds ) ax . set_aspect ( \"equal\" ) if norm : if not isinstance ( norm , mpl . colors . Normalize ): raise AttributeError ( \"norm argument should be a \" \"matplotlib.colors.Normalize object\" ) if cmap is None : cmap = self . cmap if norm is None : norm = self . norm if legend_kwds is None : legend_kwds = {} arr = self . read ( masked = True , out_shape = out_shape ) if categorical is True : if self . categorical is False : N = np . bincount ( arr ) cmap = discrete_cmap ( N , base_cmap = cmap ) vmin , vmax = None , None im = ax . imshow ( X = arr , extent = rasterio . plot . plotting_extent ( self . ds ), cmap = cmap , norm = norm , vmin = vmin , vmax = vmax , ) if legend is True : plt . colorbar ( im , cax = cax , ax = ax , ** legend_kwds ) return ax","title":"Returns"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.read","text":"Read method for a single RasterLayer. Reads the pixel values from a RasterLayer into a ndarray that always will have two dimensions in the order of (rows, columns).","title":"read()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.read--parameters","text":"**kwargs : named arguments that can be passed to the the rasterio.DatasetReader.read method. Source code in pyspatialml/rasterlayer.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 def read ( self , ** kwargs ): \"\"\"Read method for a single RasterLayer. Reads the pixel values from a RasterLayer into a ndarray that always will have two dimensions in the order of (rows, columns). Parameters ---------- **kwargs : named arguments that can be passed to the the rasterio.DatasetReader.read method. \"\"\" if \"resampling\" in kwargs . keys (): resampling_methods = [ i . name for i in rasterio . enums . Resampling ] if kwargs [ \"resampling\" ] not in resampling_methods : raise ValueError ( \"Invalid resampling method. Resampling \" \"method must be one of {0} :\" . format ( resampling_methods ) ) kwargs [ \"resampling\" ] = rasterio . enums . Resampling [ kwargs [ \"resampling\" ]] return self . ds . read ( indexes = self . bidx , ** kwargs )","title":"Parameters"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.stddev","text":"Standard deviation","title":"stddev()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.stddev--parameters","text":"int Number of pixels used to inform statistical estimate.","title":"Parameters"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.stddev--returns","text":"numpy.float32 The standard deviation of the object's pixels. Source code in pyspatialml/rasterlayer.py 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 def stddev ( self , max_pixels = 10000 ): \"\"\"Standard deviation Parameters ---------- max_pixels : int Number of pixels used to inform statistical estimate. Returns ------- numpy.float32 The standard deviation of the object's pixels. \"\"\" arr = self . _stats ( max_pixels ) return np . nanstd ( arr )","title":"Returns"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.write","text":"Write method for a single RasterLayer.","title":"write()"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.write--parameters","text":"str (opt) File path to save the dataset. str GDAL-compatible driver used for the file format. str (opt) Numpy dtype used for the file. If omitted then the RasterLayer's dtype is used. any number (opt) A value used to represent the nodata pixels. If omitted then the RasterLayer's nodata value is used (if assigned already). opt Optional named arguments to pass to the format drivers. For example can be compress=\"deflate\" to add compression.","title":"Parameters"},{"location":"api/#pyspatialml.rasterlayer.RasterLayer.write--returns","text":"pyspatialml.RasterLayer Source code in pyspatialml/rasterlayer.py 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 def write ( self , file_path , driver = \"GTiff\" , dtype = None , nodata = None , ** kwargs ): \"\"\"Write method for a single RasterLayer. Parameters ---------- file_path : str (opt) File path to save the dataset. driver : str GDAL-compatible driver used for the file format. dtype : str (opt) Numpy dtype used for the file. If omitted then the RasterLayer's dtype is used. nodata : any number (opt) A value used to represent the nodata pixels. If omitted then the RasterLayer's nodata value is used (if assigned already). kwargs : opt Optional named arguments to pass to the format drivers. For example can be `compress=\"deflate\"` to add compression. Returns ------- pyspatialml.RasterLayer \"\"\" if dtype is None : dtype = self . dtype if nodata is None : nodata = get_nodata_value ( dtype ) meta = self . ds . meta meta [ \"driver\" ] = driver meta [ \"nodata\" ] = nodata meta [ \"dtype\" ] = dtype meta . update ( kwargs ) # mask any nodata values arr = np . ma . masked_equal ( self . read (), self . nodata ) arr = arr . filled ( fill_value = nodata ) # write to file with rasterio . open ( file_path , mode = \"w\" , ** meta ) as dst : dst . write ( arr . astype ( dtype ), 1 ) src = rasterio . open ( file_path ) band = rasterio . band ( src , 1 ) layer = RasterLayer ( band ) return layer","title":"Returns"},{"location":"api/#pyspatialml.transformers.GeoDistTransformer","text":"Bases: BaseEstimator , TransformerMixin Transformer to add new features based on geographical distances to reference locations.","title":"GeoDistTransformer"},{"location":"api/#pyspatialml.transformers.GeoDistTransformer--parameters","text":"ndarray Array of coordinates of reference locations in (m, n-dimensional) order, such as {n_locations, x_coordinates, y_coordinates, ...} for as many dimensions as required. For example to calculate distances to a single x,y,z location: refs = [-57.345, -110.134, 1012] And to calculate distances to three x,y reference locations: refs = [ [-57.345, -110.134], [-56.345, -109.123], [-58.534, -112.123] ] The supplied array has to have at least x,y coordinates with a (1, 2) shape for a single location. bool, default is False Optionally calculate the minimum distance to the combined reference locations, resulting in a single new feature, rather than a new feature for each individual reference location. bool (opt), default=False Optionally log-transform the distance measures.","title":"Parameters"},{"location":"api/#pyspatialml.transformers.GeoDistTransformer--returns","text":"ndarray Array of shape (n_samples, n_features) with new geodistance features appended to the right-most columns of the array. Source code in pyspatialml/transformers.py 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 class GeoDistTransformer ( BaseEstimator , TransformerMixin ): \"\"\"Transformer to add new features based on geographical distances to reference locations. Parameters ---------- refs : ndarray Array of coordinates of reference locations in (m, n-dimensional) order, such as {n_locations, x_coordinates, y_coordinates, ...} for as many dimensions as required. For example to calculate distances to a single x,y,z location: refs = [-57.345, -110.134, 1012] And to calculate distances to three x,y reference locations: refs = [ [-57.345, -110.134], [-56.345, -109.123], [-58.534, -112.123] ] The supplied array has to have at least x,y coordinates with a (1, 2) shape for a single location. minimum : bool, default is False Optionally calculate the minimum distance to the combined reference locations, resulting in a single new feature, rather than a new feature for each individual reference location. log : bool (opt), default=False Optionally log-transform the distance measures. Returns ------- X_new : ndarray Array of shape (n_samples, n_features) with new geodistance features appended to the right-most columns of the array. \"\"\" def __init__ ( self , refs , minimum = False , log = False ): self . refs = refs self . log = log self . refs_ = None self . minimum = minimum def fit ( self , X , y = None ): self . refs_ = np . asarray ( self . refs ) if self . refs_ . ndim < 2 : raise ValueError ( \"`refs` has to be a m,n-dimensional array with at least two dimensions\" ) return self def transform ( self , X , y = None ): if self . minimum is False : dists = cdist ( self . refs_ , X ) . transpose () if self . minimum is True : tree = cKDTree ( self . refs_ ) dists , _ = tree . query ( X ) if self . log is True : dists = np . log ( dists ) return np . column_stack (( X , dists ))","title":"Returns"},{"location":"api/#pyspatialml.transformers.KNNTransformer","text":"Bases: BaseEstimator , TransformerMixin Transformer to generate new lag features by weighted aggregation of K-neighboring observations. A lag transformer uses a weighted mean/mode of the values of the K-neighboring observations to generate new lagged features. The weighted mean/mode of the surrounding observations are appended as a new feature to the right-most column in the training data. The K-neighboring observations are determined using the distance metric specified in the metric argument. The default metric is minkowski, and with p=2 is equivalent to the standard Euclidean metric.","title":"KNNTransformer"},{"location":"api/#pyspatialml.transformers.KNNTransformer--parameters","text":"int, default = 7 Number of neighbors to use by default for kneighbors queries. {\u2018uniform\u2019, \u2018distance\u2019} or callable, default=\u2019distance\u2019 Weight function used in prediction. Possible values: - \u2018uniform\u2019 : uniform weights. All points in each neighborhood are weighted equally. - \u2018distance\u2019 : weight points by the inverse of their distance. In this case, closer neighbors of a query point will have a greater influence than neighbors which are further away. - [callable] : a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights. {'mean', 'mode'} Function that is used to apply the weights to y . Use 'mean' if the target variable is continuous and 'mode' if the target variable is discrete. float, default=1.0 Range of parameter space to use by default for radius_neighbors queries. {\u2018auto\u2019, \u2018ball_tree\u2019, \u2018kd_tree\u2019, \u2018brute\u2019}, default=\u2019auto\u2019 Algorithm used to compute the nearest neighbors: - \u2018ball_tree\u2019 will use BallTree - \u2018kd_tree\u2019 will use KDTree - \u2018brute\u2019 will use a brute-force search. - \u2018auto\u2019 will attempt to decide the most appropriate algorithm based on the values passed to fit method. - Note: fitting on sparse input will override the setting of this parameter, using brute force. int, default=30 Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem. str or callable, default=\u2019minkowski\u2019 The distance metric to use for the tree. The default metric is minkowski, and with p=2 is equivalent to the standard Euclidean metric. See the documentation of DistanceMetric for a list of available metrics. If metric is \u201cprecomputed\u201d, X is assumed to be a distance matrix and must be square during fit. X may be a sparse graph, in which case only \u201cnonzero\u201d elements may be considered neighbors. int, default=2 Parameter for the Minkowski metric from sklearn.metrics.pairwise.pairwise_distances. When p = 1, this is equivalent to using manhattan_distance (l1), and euclidean_distance (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used. bool, default=True Whether to normalize the inputs using sklearn.preprocessing.Normalizer dict, default=None Additional keyword arguments for the metric function. dict, default=None Additional keyword arguments to pass to a custom kernel function. int, default=None The number of parallel jobs to run for neighbors search. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details. Source code in pyspatialml/transformers.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 class KNNTransformer ( BaseEstimator , TransformerMixin ): \"\"\"Transformer to generate new lag features by weighted aggregation of K-neighboring observations. A lag transformer uses a weighted mean/mode of the values of the K-neighboring observations to generate new lagged features. The weighted mean/mode of the surrounding observations are appended as a new feature to the right-most column in the training data. The K-neighboring observations are determined using the distance metric specified in the `metric` argument. The default metric is minkowski, and with p=2 is equivalent to the standard Euclidean metric. Parameters ---------- n_neighbors : int, default = 7 Number of neighbors to use by default for kneighbors queries. weights : {\u2018uniform\u2019, \u2018distance\u2019} or callable, default=\u2019distance\u2019 Weight function used in prediction. Possible values: - \u2018uniform\u2019 : uniform weights. All points in each neighborhood are weighted equally. - \u2018distance\u2019 : weight points by the inverse of their distance. In this case, closer neighbors of a query point will have a greater influence than neighbors which are further away. - [callable] : a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights. measure : {'mean', 'mode'} Function that is used to apply the weights to `y`. Use 'mean' if the target variable is continuous and 'mode' if the target variable is discrete. radius : float, default=1.0 Range of parameter space to use by default for radius_neighbors queries. algorithm: {\u2018auto\u2019, \u2018ball_tree\u2019, \u2018kd_tree\u2019, \u2018brute\u2019}, default=\u2019auto\u2019 Algorithm used to compute the nearest neighbors: - \u2018ball_tree\u2019 will use BallTree - \u2018kd_tree\u2019 will use KDTree - \u2018brute\u2019 will use a brute-force search. - \u2018auto\u2019 will attempt to decide the most appropriate algorithm based on the values passed to fit method. - Note: fitting on sparse input will override the setting of this parameter, using brute force. leaf_size : int, default=30 Leaf size passed to BallTree or KDTree. This can affect the speed of the construction and query, as well as the memory required to store the tree. The optimal value depends on the nature of the problem. metric : str or callable, default=\u2019minkowski\u2019 The distance metric to use for the tree. The default metric is minkowski, and with p=2 is equivalent to the standard Euclidean metric. See the documentation of DistanceMetric for a list of available metrics. If metric is \u201cprecomputed\u201d, X is assumed to be a distance matrix and must be square during fit. X may be a sparse graph, in which case only \u201cnonzero\u201d elements may be considered neighbors. p : int, default=2 Parameter for the Minkowski metric from sklearn.metrics.pairwise.pairwise_distances. When p = 1, this is equivalent to using manhattan_distance (l1), and euclidean_distance (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used. normalize : bool, default=True Whether to normalize the inputs using sklearn.preprocessing.Normalizer metric_params : dict, default=None Additional keyword arguments for the metric function. kernel_params : dict, default=None Additional keyword arguments to pass to a custom kernel function. n_jobs : int, default=None The number of parallel jobs to run for neighbors search. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details. \"\"\" def __init__ ( self , n_neighbors = 7 , weights = \"distance\" , measure = \"mean\" , radius = 1.0 , algorithm = \"auto\" , leaf_size = 30 , metric = \"minkowski\" , p = 2 , normalize = True , metric_params = None , kernel_params = None , n_jobs = 1 , ): self . n_neighbors = n_neighbors self . weights = weights self . measure = measure self . radius = radius self . algorithm = algorithm self . leaf_size = leaf_size self . metric = metric self . p = p self . metric_params = metric_params self . kernel_params = kernel_params self . normalize = normalize self . n_jobs = n_jobs self . knn = NearestNeighbors ( n_neighbors = self . n_neighbors , radius = self . radius , algorithm = self . algorithm , leaf_size = self . leaf_size , metric = self . metric , p = self . p , metric_params = self . metric_params , n_jobs = self . n_jobs , ) self . y_ = None def fit ( self , X , y = None ): \"\"\"Fit the base_estimator with features from X {n_samples, n_features} and with an additional spatially lagged variable added to the right-most column of the training data. During fitting, the k-neighbors to each training point are used to estimate the spatial lag component. The training point is not included in the calculation, i.e. the training point is not considered its own neighbor. Parameters ---------- X : array-like of sample {n_samples, n_features} using for model fitting The training input samples y : array-like of shape (n_samples,) The target values (class labels in classification, real numbers in regression). \"\"\" # some checks if self . kernel_params is None : self . kernel_params = {} if y . ndim == 1 : self . n_outputs_ = 1 else : self . n_outputs_ = y . shape [ 1 ] # fit knn and get values of neighbors if self . normalize is True : scaler = Normalizer () X = scaler . fit_transform ( X ) self . scaler_ = scaler self . knn . fit ( X ) self . y_ = y . copy () return self def transform ( self , X , y = None ): \"\"\"Transform method for spatial lag models. Augments new observations with a spatial lag variable created from a weighted mean/mode (regression/classification) of k-neighboring observations. Parameters ---------- X : array-like of sample {n_samples, n_features} New samples for the prediction. y : None Not used. \"\"\" # get distances from training points to new data if self . normalize is True : X = self . scaler_ . transform ( X ) neighbor_dist , neighbor_ids = self . knn . kneighbors ( X = X ) # mask zero distances neighbor_dist = np . ma . masked_equal ( neighbor_dist , 0 ) # get values of closest training points to new data neighbor_vals = np . array ([ self . y_ [ i ] for i in neighbor_ids ]) # mask neighbor values with zero distances mask = neighbor_dist . mask if mask . all () == False : mask = np . zeros ( neighbor_dist . shape , dtype = np . bool ) mask [:] = False if neighbor_vals . ndim == 2 : neighbor_vals = np . ma . masked_array ( neighbor_vals , mask ) else : n_outputs = neighbor_vals . shape [ 2 ] mask = np . repeat ( mask [:, :, np . newaxis ], n_outputs , axis = 2 ) neighbor_vals = np . ma . masked_array ( neighbor_vals , mask = mask ) # calculated weighted means if self . weights == \"distance\" : new_X = self . _distance_weighting ( neighbor_vals , neighbor_dist ) elif self . weights == \"uniform\" : new_X = self . _uniform_weighting ( neighbor_vals ) elif callable ( self . weights ): new_X = self . _custom_weighting ( neighbor_vals , neighbor_dist ) return np . column_stack (( X , new_X )) def _apply_weights ( self , neighbor_vals , neighbor_weights ): # weighted mean/mode of neighbors for a single regression target if neighbor_vals . ndim == 2 : if self . measure == \"mean\" : X = np . ma . average ( neighbor_vals , weights = neighbor_weights , axis = 1 ) else : X , _ = weighted_mode ( neighbor_vals , neighbor_weights , axis = 1 ) # weighted mean of neighbors for a multi-target regression # neighbor_vals = (n_samples, n_neighbors, n_targets) else : X = np . zeros (( neighbor_vals . shape [ 0 ], neighbor_vals . shape [ 2 ])) if self . measure == \"mean\" : for i in range ( neighbor_vals . shape [ - 1 ]): X [:, i ] = np . ma . average ( neighbor_vals [:, :, i ], weights = neighbor_weights , axis = 1 ) else : for i in range ( neighbor_vals . shape [ - 1 ]): X [:, i ], _ = weighted_mode ( neighbor_vals [:, :, i ], neighbor_weights , axis = 1 ) return X def _distance_weighting ( self , neighbor_vals , neighbor_dist ): weights = 1 / neighbor_dist return self . _apply_weights ( neighbor_vals , weights ) def _uniform_weighting ( self , neighbor_vals ): weights = np . ones (( neighbor_vals . shape [ 0 ], neighbor_vals . shape [ 0 ])) return self . _apply_weights ( neighbor_vals , weights ) def _custom_weighting ( self , neighbor_vals , neighbor_dist ): weights = self . weights ( neighbor_dist , ** self . kernel_params ) return self . _apply_weights ( neighbor_vals , weights ) def _distance_weighting ( self , neighbor_vals , neighbor_dist ): weights = 1 / neighbor_dist return self . _apply_weights ( neighbor_vals , weights ) def _uniform_weighting ( self , neighbor_vals ): weights = np . ones (( neighbor_vals . shape [ 0 ], neighbor_vals . shape [ 0 ])) return self . _apply_weights ( neighbor_vals , weights ) def _custom_weighting ( self , neighbor_vals , neighbor_dist ): weights = self . weights ( neighbor_dist , ** self . kernel_params ) return self . _apply_weights ( neighbor_vals , weights )","title":"Parameters"},{"location":"api/#pyspatialml.transformers.KNNTransformer.fit","text":"Fit the base_estimator with features from X {n_samples, n_features} and with an additional spatially lagged variable added to the right-most column of the training data. During fitting, the k-neighbors to each training point are used to estimate the spatial lag component. The training point is not included in the calculation, i.e. the training point is not considered its own neighbor.","title":"fit()"},{"location":"api/#pyspatialml.transformers.KNNTransformer.fit--parameters","text":"array-like of sample {n_samples, n_features} using for model fitting The training input samples array-like of shape (n_samples,) The target values (class labels in classification, real numbers in regression). Source code in pyspatialml/transformers.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 def fit ( self , X , y = None ): \"\"\"Fit the base_estimator with features from X {n_samples, n_features} and with an additional spatially lagged variable added to the right-most column of the training data. During fitting, the k-neighbors to each training point are used to estimate the spatial lag component. The training point is not included in the calculation, i.e. the training point is not considered its own neighbor. Parameters ---------- X : array-like of sample {n_samples, n_features} using for model fitting The training input samples y : array-like of shape (n_samples,) The target values (class labels in classification, real numbers in regression). \"\"\" # some checks if self . kernel_params is None : self . kernel_params = {} if y . ndim == 1 : self . n_outputs_ = 1 else : self . n_outputs_ = y . shape [ 1 ] # fit knn and get values of neighbors if self . normalize is True : scaler = Normalizer () X = scaler . fit_transform ( X ) self . scaler_ = scaler self . knn . fit ( X ) self . y_ = y . copy () return self","title":"Parameters"},{"location":"api/#pyspatialml.transformers.KNNTransformer.transform","text":"Transform method for spatial lag models. Augments new observations with a spatial lag variable created from a weighted mean/mode (regression/classification) of k-neighboring observations.","title":"transform()"},{"location":"api/#pyspatialml.transformers.KNNTransformer.transform--parameters","text":"array-like of sample {n_samples, n_features} New samples for the prediction. None Not used. Source code in pyspatialml/transformers.py 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def transform ( self , X , y = None ): \"\"\"Transform method for spatial lag models. Augments new observations with a spatial lag variable created from a weighted mean/mode (regression/classification) of k-neighboring observations. Parameters ---------- X : array-like of sample {n_samples, n_features} New samples for the prediction. y : None Not used. \"\"\" # get distances from training points to new data if self . normalize is True : X = self . scaler_ . transform ( X ) neighbor_dist , neighbor_ids = self . knn . kneighbors ( X = X ) # mask zero distances neighbor_dist = np . ma . masked_equal ( neighbor_dist , 0 ) # get values of closest training points to new data neighbor_vals = np . array ([ self . y_ [ i ] for i in neighbor_ids ]) # mask neighbor values with zero distances mask = neighbor_dist . mask if mask . all () == False : mask = np . zeros ( neighbor_dist . shape , dtype = np . bool ) mask [:] = False if neighbor_vals . ndim == 2 : neighbor_vals = np . ma . masked_array ( neighbor_vals , mask ) else : n_outputs = neighbor_vals . shape [ 2 ] mask = np . repeat ( mask [:, :, np . newaxis ], n_outputs , axis = 2 ) neighbor_vals = np . ma . masked_array ( neighbor_vals , mask = mask ) # calculated weighted means if self . weights == \"distance\" : new_X = self . _distance_weighting ( neighbor_vals , neighbor_dist ) elif self . weights == \"uniform\" : new_X = self . _uniform_weighting ( neighbor_vals ) elif callable ( self . weights ): new_X = self . _custom_weighting ( neighbor_vals , neighbor_dist ) return np . column_stack (( X , new_X ))","title":"Parameters"},{"location":"api/#pyspatialml.vector.filter_points","text":"Filter points in geodataframe using a minimum distance buffer.","title":"filter_points()"},{"location":"api/#pyspatialml.vector.filter_points--args","text":"Geopandas GeoDataFrame Containing point geometries. int or float, optional (default=0) Minimum distance by which to filter out closely spaced points. str, optional (default='first') Optionally choose to remove 'first' occurrences or 'last' occurrences.","title":"Args"},{"location":"api/#pyspatialml.vector.filter_points--returns","text":"2d array-like Numpy array filtered coordinates Source code in pyspatialml/vector.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def filter_points ( gdf , min_dist = 0 , remove = \"first\" ): \"\"\"Filter points in geodataframe using a minimum distance buffer. Args ---- gdf : Geopandas GeoDataFrame Containing point geometries. min_dist : int or float, optional (default=0) Minimum distance by which to filter out closely spaced points. remove : str, optional (default='first') Optionally choose to remove 'first' occurrences or 'last' occurrences. Returns ------- xy : 2d array-like Numpy array filtered coordinates \"\"\" xy = gdf . geometry . bounds . iloc [:, 0 : 2 ] Z = linkage ( xy , \"complete\" ) tree_thres = cut_tree ( Z , height = min_dist ) gdf [ \"tree_thres\" ] = tree_thres if remove == \"first\" : gdf = gdf . groupby ( by = \"tree_thres\" ) . first () elif remove == \"last\" : gdf = gdf . groupby ( by = \"tree_thres\" ) . last () return gdf","title":"Returns"},{"location":"api/#pyspatialml.vector.get_random_point_in_polygon","text":"Generates random shapely Point geometry objects within a single shapely Polygon object.","title":"get_random_point_in_polygon()"},{"location":"api/#pyspatialml.vector.get_random_point_in_polygon--args","text":"poly : Shapely Polygon object","title":"Args"},{"location":"api/#pyspatialml.vector.get_random_point_in_polygon--returns","text":"p : Shapely Point object Source code in pyspatialml/vector.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def get_random_point_in_polygon ( poly ): \"\"\"Generates random shapely Point geometry objects within a single shapely Polygon object. Args ---- poly : Shapely Polygon object Returns ------- p : Shapely Point object \"\"\" ( minx , miny , maxx , maxy ) = poly . bounds while True : p = Point ( random . uniform ( minx , maxx ), random . uniform ( miny , maxy )) if poly . contains ( p ): return p","title":"Returns"},{"location":"design/","text":"Usage overview Pyspatialml provides access to raster datasets using two main structures, comprising the Raster and RasterLayer classes. Raster objects The main class that facilitates working with multiple raster datasets is the Raster class. The Raster object takes a list GDAL-supported raster datasets and 'stacks' them into a single Raster object. The underlying file-based raster datasets are not physically-stacked, but rather the Raster object internally represents each band within the datasets as a RasterLayer . This means that metadata regarding what each raster dataset represents (e.g. the dataset's name) can be retained, and additional raster datasets can be added or removed from the stack without physical on-disk changes. Note these raster datasets need to be spatially aligned in terms of their extent, resolution and coordinate reference system. Creating a new Raster object There are several methods of creating a new Raster object: Raster(src=[raster1.tif, raster2.tif, raster3.tif]) creates a Raster object from existing file-based GDAL-supported datasets, or a single raster dataset. The file-based datasets can contain single or multiple bands. Raster(src=new_numpy_array, crs=crs, transform=transform) creates a Raster object from a 3D numpy array (band, row, column). The crs and transform arguments are optional but are required to provide coordinate reference system information to the Raster object. The crs argument has to be represented by rasterio.crs.CRS object, and the transform parameter requires an affine.Affine object. Raster(src=[RasterLayer1, RasterLayer2, RasterLayer3]) creates a Raster object from a single or list of RasterLayer objects. RasterLayers are a thin wrapper around rasterio.Band objects with additional methods. This is mostly used internally. A RasterLayer itself is initiated directly from a rasterio.Band object. A Raster can also be initated directly from a rasterio.Band object, or a list of rasterio.Band objects. Generally, Pyspatialml intends users to work with the Raster object. However, access to individual RasterLayer objects, or the underlying rasterio.band datasets can be useful if pyspatialml is being used in conjunction with other functions and methods in the rasterio package. Overview of attributes and methods Attributes Raster.loc : Access pyspatialml.RasterLayer objects within a Raster using a key, or a list of keys. Raster.iloc : Access pyspatialml.RasterLayer objects using an index position. Raster.files : A list of the on-disk files that the Raster object references. Raster.dtypes : A list of numpy dtypes for each RasterLayer. Raster.nodatavals : A list of the nodata values for each RasterLayer. Raster.count : The number of RasterLayers in the Raster. Raster.res : The resolution in (x, y) dimensions of the Raster. Raster.meta : A dict containing the raster metadata. Raster.names : A list of the RasterLayer names. Raster.block_shape : The default block_shape in (rows, cols) for reading windows of data in the Raster for out-of-memory processing. Methods Raster.read : eads data from the Raster object into a numpy array. Raster.write : Write the Raster object to a file. Raster.predict_proba : Apply class probability prediction of a scikit learn model to a Raster. Raster.predict : Apply prediction of a scikit learn model to a Raster. Raster.append : Method to add new RasterLayers to a Raster object. Raster.drop : Drop individual RasterLayers from a Raster object. Raster.rename : Rename a RasterLayer within the Raster object. Raster.plot : Plot a Raster object as a raster matrix. Raster.mask : Mask a Raster object based on the outline of shapes in a geopandas.GeoDataFrame . Raster.intersect : Perform a intersect operation on the Raster object. Raster.crop : Crops a Raster object by the supplied bounds. Raster.to_crs : Reprojects a Raster object to a different crs. Raster.aggregate : Aggregates a raster to (usually) a coarser grid cell size. Raster.apply : Apply user-supplied function to a Raster object. Raster.block_shapes : Generator for windows for optimal reading and writing based on the raster. Raster.copy : Perform a shallow copy of a Raster object. Note only the object itself is copied, not the physical file locations that it is linked with. Raster.sample : Take a random or stratified sample from a Raster. Raster.extract_vector : Spatial query the pixels in the Raster using a geopandas.GeoDataFrame of point, line or polygon geometries. Raster.extract_raster : Spatial query the pixels in the Raster using a raster of labelled pixels. Raster.extract_xy : Extract pixel values using a list of x,y coordinates. Raster.plot : Plot a rasterplot matrix of all layers within the Raster. RasterLayer A RasterLayer is an object that represents a single raster band. It is based on a rasterio.band object with some additional attributes and methods. A RasterLayer is used because the rasterio.Band.ds.read method reads all bands from a multi-band dataset, whereas the RasterLayer read method always refers to a single band. A RasterLayer object is generally not intended to be initiated directly, but rather is used internally as part of a Raster to represent individual bands. However, a RasterLayer can be initiated from a rasterio.band object. Overview of attributes and methods Methods encapsulated in RasterLayer objects represent those that typically would only be applied to a single-band of a raster, i.e. sieve-clump, distance to non-NaN pixels, or arithmetic operations on individual layers. Attributes RasterLayer.bidx : The band index of the RasterLayer within the file dataset. RasterLayer.dtype : The data type of the RasterLayer. RasterLayer.nodata : The number that is used to represent nodata pixels in the RasterLayer. RasterLayer.file : The file path to the dataset. RasterLayer.ds : The underlying rasterio.band object. RasterLayer.driver : The name of the GDAL format driver. RasterLayer.meta : A python dict storing the RasterLayer metadata. RasterLayer.cmap : The name of matplotlib map, or a custom matplotlib.cm.LinearSegmentedColormap or ListedColormap object. RasterLayer.norm : A matplotlib.colors.Normalize to apply to the RasterLayer. RasterLayer.count : Number of layers; always equal to 1. RasterLayer.name : A name that is assigned to the RasterLayer, usually created when a parent Raster object is initiated. Methods RasterLayer.close : Closes a RasterLayer. RasterLayer.read : Reads data from the RasterLayer into a numpy array. RasterLayer.write : Write the RasterLayer to a GDAL-supported raster dataset. RasterLayer.fill : Fill nodata gaps in a RasterLayer. Wrapper around the rasterio.fill.fillnodata method. RasterLayer.sieve : Replace pixels with their largest neighbor. Wrapper around the rasterio.features.sieve method. RasterLayer.distance : Calculate euclidean grid distances to non-NaN pixels. RasterLayer.plot : Plot a RasterLayer using matplotlib.pyplot.imshow . RasterLayer.min , RasterLayer.max , RasterLayer.mean , RasterLayer.median : Basic summary statistics for a layer.","title":"Usage overview"},{"location":"design/#usage-overview","text":"Pyspatialml provides access to raster datasets using two main structures, comprising the Raster and RasterLayer classes.","title":"Usage overview"},{"location":"design/#raster-objects","text":"The main class that facilitates working with multiple raster datasets is the Raster class. The Raster object takes a list GDAL-supported raster datasets and 'stacks' them into a single Raster object. The underlying file-based raster datasets are not physically-stacked, but rather the Raster object internally represents each band within the datasets as a RasterLayer . This means that metadata regarding what each raster dataset represents (e.g. the dataset's name) can be retained, and additional raster datasets can be added or removed from the stack without physical on-disk changes. Note these raster datasets need to be spatially aligned in terms of their extent, resolution and coordinate reference system.","title":"Raster objects"},{"location":"design/#creating-a-new-raster-object","text":"There are several methods of creating a new Raster object: Raster(src=[raster1.tif, raster2.tif, raster3.tif]) creates a Raster object from existing file-based GDAL-supported datasets, or a single raster dataset. The file-based datasets can contain single or multiple bands. Raster(src=new_numpy_array, crs=crs, transform=transform) creates a Raster object from a 3D numpy array (band, row, column). The crs and transform arguments are optional but are required to provide coordinate reference system information to the Raster object. The crs argument has to be represented by rasterio.crs.CRS object, and the transform parameter requires an affine.Affine object. Raster(src=[RasterLayer1, RasterLayer2, RasterLayer3]) creates a Raster object from a single or list of RasterLayer objects. RasterLayers are a thin wrapper around rasterio.Band objects with additional methods. This is mostly used internally. A RasterLayer itself is initiated directly from a rasterio.Band object. A Raster can also be initated directly from a rasterio.Band object, or a list of rasterio.Band objects. Generally, Pyspatialml intends users to work with the Raster object. However, access to individual RasterLayer objects, or the underlying rasterio.band datasets can be useful if pyspatialml is being used in conjunction with other functions and methods in the rasterio package.","title":"Creating a new Raster object"},{"location":"design/#overview-of-attributes-and-methods","text":"","title":"Overview of attributes and methods"},{"location":"design/#attributes","text":"Raster.loc : Access pyspatialml.RasterLayer objects within a Raster using a key, or a list of keys. Raster.iloc : Access pyspatialml.RasterLayer objects using an index position. Raster.files : A list of the on-disk files that the Raster object references. Raster.dtypes : A list of numpy dtypes for each RasterLayer. Raster.nodatavals : A list of the nodata values for each RasterLayer. Raster.count : The number of RasterLayers in the Raster. Raster.res : The resolution in (x, y) dimensions of the Raster. Raster.meta : A dict containing the raster metadata. Raster.names : A list of the RasterLayer names. Raster.block_shape : The default block_shape in (rows, cols) for reading windows of data in the Raster for out-of-memory processing.","title":"Attributes"},{"location":"design/#methods","text":"Raster.read : eads data from the Raster object into a numpy array. Raster.write : Write the Raster object to a file. Raster.predict_proba : Apply class probability prediction of a scikit learn model to a Raster. Raster.predict : Apply prediction of a scikit learn model to a Raster. Raster.append : Method to add new RasterLayers to a Raster object. Raster.drop : Drop individual RasterLayers from a Raster object. Raster.rename : Rename a RasterLayer within the Raster object. Raster.plot : Plot a Raster object as a raster matrix. Raster.mask : Mask a Raster object based on the outline of shapes in a geopandas.GeoDataFrame . Raster.intersect : Perform a intersect operation on the Raster object. Raster.crop : Crops a Raster object by the supplied bounds. Raster.to_crs : Reprojects a Raster object to a different crs. Raster.aggregate : Aggregates a raster to (usually) a coarser grid cell size. Raster.apply : Apply user-supplied function to a Raster object. Raster.block_shapes : Generator for windows for optimal reading and writing based on the raster. Raster.copy : Perform a shallow copy of a Raster object. Note only the object itself is copied, not the physical file locations that it is linked with. Raster.sample : Take a random or stratified sample from a Raster. Raster.extract_vector : Spatial query the pixels in the Raster using a geopandas.GeoDataFrame of point, line or polygon geometries. Raster.extract_raster : Spatial query the pixels in the Raster using a raster of labelled pixels. Raster.extract_xy : Extract pixel values using a list of x,y coordinates. Raster.plot : Plot a rasterplot matrix of all layers within the Raster.","title":"Methods"},{"location":"design/#rasterlayer","text":"A RasterLayer is an object that represents a single raster band. It is based on a rasterio.band object with some additional attributes and methods. A RasterLayer is used because the rasterio.Band.ds.read method reads all bands from a multi-band dataset, whereas the RasterLayer read method always refers to a single band. A RasterLayer object is generally not intended to be initiated directly, but rather is used internally as part of a Raster to represent individual bands. However, a RasterLayer can be initiated from a rasterio.band object.","title":"RasterLayer"},{"location":"design/#overview-of-attributes-and-methods_1","text":"Methods encapsulated in RasterLayer objects represent those that typically would only be applied to a single-band of a raster, i.e. sieve-clump, distance to non-NaN pixels, or arithmetic operations on individual layers.","title":"Overview of attributes and methods"},{"location":"design/#attributes_1","text":"RasterLayer.bidx : The band index of the RasterLayer within the file dataset. RasterLayer.dtype : The data type of the RasterLayer. RasterLayer.nodata : The number that is used to represent nodata pixels in the RasterLayer. RasterLayer.file : The file path to the dataset. RasterLayer.ds : The underlying rasterio.band object. RasterLayer.driver : The name of the GDAL format driver. RasterLayer.meta : A python dict storing the RasterLayer metadata. RasterLayer.cmap : The name of matplotlib map, or a custom matplotlib.cm.LinearSegmentedColormap or ListedColormap object. RasterLayer.norm : A matplotlib.colors.Normalize to apply to the RasterLayer. RasterLayer.count : Number of layers; always equal to 1. RasterLayer.name : A name that is assigned to the RasterLayer, usually created when a parent Raster object is initiated.","title":"Attributes"},{"location":"design/#methods_1","text":"RasterLayer.close : Closes a RasterLayer. RasterLayer.read : Reads data from the RasterLayer into a numpy array. RasterLayer.write : Write the RasterLayer to a GDAL-supported raster dataset. RasterLayer.fill : Fill nodata gaps in a RasterLayer. Wrapper around the rasterio.fill.fillnodata method. RasterLayer.sieve : Replace pixels with their largest neighbor. Wrapper around the rasterio.features.sieve method. RasterLayer.distance : Calculate euclidean grid distances to non-NaN pixels. RasterLayer.plot : Plot a RasterLayer using matplotlib.pyplot.imshow . RasterLayer.min , RasterLayer.max , RasterLayer.mean , RasterLayer.median : Basic summary statistics for a layer.","title":"Methods"},{"location":"geoprocessing/","text":"Raster Geoprocessing Pyspatialml includes common geoprocessing methods that collectively operate on stacks of raster datasets, such as cropping, reprojecting, masking etc. Most of these methods are simple wrappers around underlying rasterio functions, but applied to stacks of raster datasets. Handling of Temporary Files All of the geoprocessing methods have a file_path parameter to specify a file path to save the results of th geoprocessing operation. However, pyspatialml is designed for quick an interactive analyses on raster datasets, and if a file path is not specified then the results are saved to a temporary file location and a new Raster object is returned with the geoprocessing results. For datasets that will easily fit into memory, all geoprocessing methods also have an in_memory parameter. If in_memory=True is set, then the results will be created using Rasterio's in-memory files and stored in RAM. This has performance advantages, at the expense of memory expenditure. Cropping All layers within a Raster can be cropped to a new extent using the Raster.crop method. import geopandas as gpd from pyspatialml import Raster from pyspatialml.datasets import nc predictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7] stack = Raster(predictors) # crop to new extent (xmin, ymin, xmax, ymax) crop_bounds = training_py.loc[0, \"geometry\"].bounds stack_cropped = stack.crop(self.crop_bounds) Masking In comparison to cropping, masking can be used to set pixels that occur outside of masking geometries to NaN, and optionally can also crop a Raster. import geopandas as gpd import pyspatialml.datasets.nc as nc from pyspatialml import Raster training_py = gpd.read_file(nc.polygons) mask_py = training_py.iloc[0:1, :] predictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7] stack = Raster(predictors) # mask a Raster masked_object = stack.mask(mask_py) Intersecting Layers The Raster.intersect method computes the geometric intersection of the RasterLayers with the Raster object. This will cause nodata values in any of the rasters to be propagated through all of the output rasters. import pyspatialml.datasets.nc as nc from pyspatialml import Raster predictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7] stack = Raster(predictors) result = stack.intersect() The intersect method is memory-safe, i.e. the intersection occurs during windowed reading and writing of the Raster. The size and dimensions of the windows can be changed using the Raster.block_shapes property. Reprojecting Reprojecting a raster using the Raster.to_crs method. stack_prj = stack.to_crs(crs={\"init\": \"EPSG:4326\"}) Other parameters that can be passed and their defaults are resampling=\"nearest\", file_path=None, driver=\"GTiff\", nodata=None, n_jobs=1, warp_mem_lim=0, progress=False, and other kwargs that are passed to the raster format drivers. Resampling The Raster.aggregate method is used to resample a raster to a different resolution using the decimated reading approach in the rasterio library. stack.aggregate(out_shape, resampling=\"nearest\", file_path=None, driver=\"GTiff\", dtype=None, nodata=None, **kwargs) Computation Apply user-supplied function to a Raster object. stack.apply(self, function, file_path=None, driver=\"GTiff\", dtype=None, nodata=None, progress=False, n_jobs=-1, function_args={}, **kwargs) Where function is a user-defined python that takes an numpy array as a single argument, and can return either a 2d array that represents a single raster dataset, such as NDVI, or can operate on a number of layers and can return a raster with multiple layers in a 3d array in (layer, row, col) order. The apply function is memory-safe, i.e. it applies the function to windows of the raster data that are read sequentially or in parallel (with n_jobs != 1). The size and dimensions of the windows can be changed using the Raster.block_shapes property. Raster Algebra RasterLayer objects also support basic raster math operations using python's magic methods, which supports all of the usual math operators. Calculations on RasterLayers occur in memory using Rasterio's in-memory files, thus they are not memory safe. For applying computations and algebra to large raster datasets in windows, use Raster.apply() . a = stack.iloc[0] + stack.iloc[1] b = stack.iloc[0] - stack.iloc[1] ndvi = (stack.iloc[3] - stack.iloc[2]) / (stack.iloc[3] + stack.iloc[2]) Arithmetic operations on RasterLayer's will return another RasterLayer. The result can be coerced into a Raster object using: ndvi = Raster((stack.iloc[3] - stack.iloc[2]) / (stack.iloc[3] + stack.iloc[2])) Currently, arithmetic operations are only supported on RasterLayer objects and not in a parent Raster object directly.","title":"Raster geoprocessing"},{"location":"geoprocessing/#raster-geoprocessing","text":"Pyspatialml includes common geoprocessing methods that collectively operate on stacks of raster datasets, such as cropping, reprojecting, masking etc. Most of these methods are simple wrappers around underlying rasterio functions, but applied to stacks of raster datasets.","title":"Raster Geoprocessing"},{"location":"geoprocessing/#handling-of-temporary-files","text":"All of the geoprocessing methods have a file_path parameter to specify a file path to save the results of th geoprocessing operation. However, pyspatialml is designed for quick an interactive analyses on raster datasets, and if a file path is not specified then the results are saved to a temporary file location and a new Raster object is returned with the geoprocessing results. For datasets that will easily fit into memory, all geoprocessing methods also have an in_memory parameter. If in_memory=True is set, then the results will be created using Rasterio's in-memory files and stored in RAM. This has performance advantages, at the expense of memory expenditure.","title":"Handling of Temporary Files"},{"location":"geoprocessing/#cropping","text":"All layers within a Raster can be cropped to a new extent using the Raster.crop method. import geopandas as gpd from pyspatialml import Raster from pyspatialml.datasets import nc predictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7] stack = Raster(predictors) # crop to new extent (xmin, ymin, xmax, ymax) crop_bounds = training_py.loc[0, \"geometry\"].bounds stack_cropped = stack.crop(self.crop_bounds)","title":"Cropping"},{"location":"geoprocessing/#masking","text":"In comparison to cropping, masking can be used to set pixels that occur outside of masking geometries to NaN, and optionally can also crop a Raster. import geopandas as gpd import pyspatialml.datasets.nc as nc from pyspatialml import Raster training_py = gpd.read_file(nc.polygons) mask_py = training_py.iloc[0:1, :] predictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7] stack = Raster(predictors) # mask a Raster masked_object = stack.mask(mask_py)","title":"Masking"},{"location":"geoprocessing/#intersecting-layers","text":"The Raster.intersect method computes the geometric intersection of the RasterLayers with the Raster object. This will cause nodata values in any of the rasters to be propagated through all of the output rasters. import pyspatialml.datasets.nc as nc from pyspatialml import Raster predictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7] stack = Raster(predictors) result = stack.intersect() The intersect method is memory-safe, i.e. the intersection occurs during windowed reading and writing of the Raster. The size and dimensions of the windows can be changed using the Raster.block_shapes property.","title":"Intersecting Layers"},{"location":"geoprocessing/#reprojecting","text":"Reprojecting a raster using the Raster.to_crs method. stack_prj = stack.to_crs(crs={\"init\": \"EPSG:4326\"}) Other parameters that can be passed and their defaults are resampling=\"nearest\", file_path=None, driver=\"GTiff\", nodata=None, n_jobs=1, warp_mem_lim=0, progress=False, and other kwargs that are passed to the raster format drivers.","title":"Reprojecting"},{"location":"geoprocessing/#resampling","text":"The Raster.aggregate method is used to resample a raster to a different resolution using the decimated reading approach in the rasterio library. stack.aggregate(out_shape, resampling=\"nearest\", file_path=None, driver=\"GTiff\", dtype=None, nodata=None, **kwargs)","title":"Resampling"},{"location":"geoprocessing/#computation","text":"Apply user-supplied function to a Raster object. stack.apply(self, function, file_path=None, driver=\"GTiff\", dtype=None, nodata=None, progress=False, n_jobs=-1, function_args={}, **kwargs) Where function is a user-defined python that takes an numpy array as a single argument, and can return either a 2d array that represents a single raster dataset, such as NDVI, or can operate on a number of layers and can return a raster with multiple layers in a 3d array in (layer, row, col) order. The apply function is memory-safe, i.e. it applies the function to windows of the raster data that are read sequentially or in parallel (with n_jobs != 1). The size and dimensions of the windows can be changed using the Raster.block_shapes property.","title":"Computation"},{"location":"geoprocessing/#raster-algebra","text":"RasterLayer objects also support basic raster math operations using python's magic methods, which supports all of the usual math operators. Calculations on RasterLayers occur in memory using Rasterio's in-memory files, thus they are not memory safe. For applying computations and algebra to large raster datasets in windows, use Raster.apply() . a = stack.iloc[0] + stack.iloc[1] b = stack.iloc[0] - stack.iloc[1] ndvi = (stack.iloc[3] - stack.iloc[2]) / (stack.iloc[3] + stack.iloc[2]) Arithmetic operations on RasterLayer's will return another RasterLayer. The result can be coerced into a Raster object using: ndvi = Raster((stack.iloc[3] - stack.iloc[2]) / (stack.iloc[3] + stack.iloc[2])) Currently, arithmetic operations are only supported on RasterLayer objects and not in a parent Raster object directly.","title":"Raster Algebra"},{"location":"mlworkflow/","text":"A Machine Learning Example Extraction Training Data Load some training data in the form of polygons, points and labelled pixels in geopandas.GeoDataFrame objects. We will also generate some line geometries by converting the polygon boundaries into linestrings. All of these geometry types can be used to spatially query pixel values in a Raster object, however each GeoDataFrame must contain only one type of geometry (i.e. either shapely points, polygons or linestrings). from pyspatialml import Raster from pyspatialml.datasets import nc from copy import deepcopy import os import tempfile import geopandas import rasterio.plot import matplotlib.pyplot as plt training_py = geopandas.read_file(nc.polygons) training_pt = geopandas.read_file(nc.points) training_px = rasterio.open(nc.labelled_pixels) training_lines = deepcopy(training_py) training_lines['geometry'] = training_lines.geometry.boundary Show training data points and a single raster band using numpy and matplotlib: predictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7] stack = Raster(predictors) fig, ax = plt.subplots(figsize=(9, 9)) stack.lsat7_2000_70.plot(ax=ax) training_py.plot(column=\"label\", ax=ax, legend=True) plt.show() Pixel values in the Raster object can be spatially queried using the extract_vector and extract_raster methods. In addition, the extract_xy method can be used to query pixel values using a 2d array of x and y coordinates. The extract_vector method accepts a Geopandas GeoDataFrame as the gdf argument. For GeoDataFrames containing shapely point geometries, the closest pixel to each point is sampled. For shapely polygon geometries, all pixels whose centres are inside the polygon are sampled. For shapely linestring geometries, every pixel touched by the line is sampled. For all geometry types, pixel values are queries for each geometry separately. This means that overlapping polygons or points that fall within the same pixel with cause the same pixel to be sampled multiple times. By default, the extract functions return a Geopandas GeoDataFrame of point geometries and the DataFrame containing the extracted pixels, with the column names set by the names of the raster datasets in the Raster object. The user can also use the return_array=True argument, which instead of returning a DataFrame will return three masked numpy arrays (ids, X, xy) containing the geodataframe index positions, extracted pixel values, and the spatial coordinates of the sampled pixels. These arrays are masked arrays. The extract_raster method can also be used to spatially query pixel values from a Raster object using another raster containing labelled pixels. This raster has to be spatially aligned with the Raster object. The values of the labelled pixels are returned along with the queried pixel values. # Extract data from rasters at the training point locations: df_points = stack.extract_vector(training_pt) df_polygons = stack.extract_vector(training_py) df_lines = stack.extract_vector(training_lines) For any vector features, a GeoDataFrame is returned containing the extracted pixel values. A pandas.MultiIndex is used to relate the pixels back to the original geometries, with the pixel_idx index referring to the index of each pixel, and the geometry_idx referring to the index of the original geometry in the supplied GeoDataFrame. The pixel values themselves are represented as shapely.geometry.Point objects. These will need to be joined back with the columns of the vector features to get the labelled classes. Here we will join the extracted pixels using the \"id\" column and the GeoDataFrame index of the vector features: # Join the extracted values with other columns from the training data df_points[\"id\"] = training_pt[\"id\"].values df_points = df_points.dropna() df_points.head() df_polygons = df_polygons.merge( right=training_py.loc[:, [\"label\", \"id\"]], left_on=\"geometry_idx\", right_on=\"index\", right_index=True ) If the training data is from labelled pixels in a raster, then the extracted data will contain a \"value\" column that contains the pixel labels: df_raster = stack.extract_raster(training_px) Model Training Next we can train a logistic regression classifier: from sklearn.linear_model import LogisticRegressionCV from sklearn.preprocessing import StandardScaler from sklearn.pipeline import Pipeline from sklearn.model_selection import cross_validate # define the classifier with standardization of the input features in a # pipeline lr = Pipeline( [('scaling', StandardScaler()), ('classifier', LogisticRegressionCV(n_jobs=-1))]) # remove NaNs from training data df_polygons = df_polygons.dropna() # fit the classifier X = df_polygons.drop(columns=[\"id\", \"label\", \"geometry\"]).values y = df_polygons[\"id\"].values lr.fit(X, y) After defining a classifier, a typical step consists of performing a cross-validation to evaluate the performance of the model. Scikit-learn provides the cross_validate function for this purpose. In comparison to non-spatial data, spatial data can be spatially correlated, which potentially can mean that geographically proximal samples may not represent truely independent samples if they are within the autocorrelation range of some of the predictors. This will lead to overly optimistic performance measures if samples in the training dataset / cross-validation partition are strongly spatially correlated with samples in the test dataset / cross-validation partition. In this case, performing cross-validation using groups is useful, because these groups can represent spatial clusters of training samples, and samples from the same group will never occur in both the training and test partitions of a cross-validation. Here we can use the polygon indices as the groups, i.e. pixels within the same polygon will not be split into training and test partitions: scores = cross_validate( estimator=lr, X=X, y=y, groups=df_polygons.index.droplevel(\"pixel_idx\"), scoring=\"accuracy\", cv=3, n_jobs=1, ) scores['test_score'].mean() Raster Prediction Prediction on the Raster object is performed using the predict method. The estimator is the only required argument. If the file_path argument is not specified then the result is automatically written to a temporary file. The predict method returns an rasterio.io.DatasetReader object which is open. # prediction result = stack.predict(estimator=lr, dtype='int16', nodata=0) result_probs = stack.predict_proba(estimator=lr) # plot classification result result.iloc[0].cmap = \"Dark2\" result.iloc[0].categorical = True result.plot() plt.show() The predict_proba method can be used to output class probabilities as a multi-band raster (a band for each class probability). In the latter case, indexes can also be supplied if you only want to output the probabilities for a particular class, or list of classes, by supplying the indices of those classes: # plot class probabilities result_probs.plot() plt.show()","title":"Example workflow"},{"location":"mlworkflow/#a-machine-learning-example","text":"","title":"A Machine Learning Example"},{"location":"mlworkflow/#extraction-training-data","text":"Load some training data in the form of polygons, points and labelled pixels in geopandas.GeoDataFrame objects. We will also generate some line geometries by converting the polygon boundaries into linestrings. All of these geometry types can be used to spatially query pixel values in a Raster object, however each GeoDataFrame must contain only one type of geometry (i.e. either shapely points, polygons or linestrings). from pyspatialml import Raster from pyspatialml.datasets import nc from copy import deepcopy import os import tempfile import geopandas import rasterio.plot import matplotlib.pyplot as plt training_py = geopandas.read_file(nc.polygons) training_pt = geopandas.read_file(nc.points) training_px = rasterio.open(nc.labelled_pixels) training_lines = deepcopy(training_py) training_lines['geometry'] = training_lines.geometry.boundary Show training data points and a single raster band using numpy and matplotlib: predictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7] stack = Raster(predictors) fig, ax = plt.subplots(figsize=(9, 9)) stack.lsat7_2000_70.plot(ax=ax) training_py.plot(column=\"label\", ax=ax, legend=True) plt.show() Pixel values in the Raster object can be spatially queried using the extract_vector and extract_raster methods. In addition, the extract_xy method can be used to query pixel values using a 2d array of x and y coordinates. The extract_vector method accepts a Geopandas GeoDataFrame as the gdf argument. For GeoDataFrames containing shapely point geometries, the closest pixel to each point is sampled. For shapely polygon geometries, all pixels whose centres are inside the polygon are sampled. For shapely linestring geometries, every pixel touched by the line is sampled. For all geometry types, pixel values are queries for each geometry separately. This means that overlapping polygons or points that fall within the same pixel with cause the same pixel to be sampled multiple times. By default, the extract functions return a Geopandas GeoDataFrame of point geometries and the DataFrame containing the extracted pixels, with the column names set by the names of the raster datasets in the Raster object. The user can also use the return_array=True argument, which instead of returning a DataFrame will return three masked numpy arrays (ids, X, xy) containing the geodataframe index positions, extracted pixel values, and the spatial coordinates of the sampled pixels. These arrays are masked arrays. The extract_raster method can also be used to spatially query pixel values from a Raster object using another raster containing labelled pixels. This raster has to be spatially aligned with the Raster object. The values of the labelled pixels are returned along with the queried pixel values. # Extract data from rasters at the training point locations: df_points = stack.extract_vector(training_pt) df_polygons = stack.extract_vector(training_py) df_lines = stack.extract_vector(training_lines) For any vector features, a GeoDataFrame is returned containing the extracted pixel values. A pandas.MultiIndex is used to relate the pixels back to the original geometries, with the pixel_idx index referring to the index of each pixel, and the geometry_idx referring to the index of the original geometry in the supplied GeoDataFrame. The pixel values themselves are represented as shapely.geometry.Point objects. These will need to be joined back with the columns of the vector features to get the labelled classes. Here we will join the extracted pixels using the \"id\" column and the GeoDataFrame index of the vector features: # Join the extracted values with other columns from the training data df_points[\"id\"] = training_pt[\"id\"].values df_points = df_points.dropna() df_points.head() df_polygons = df_polygons.merge( right=training_py.loc[:, [\"label\", \"id\"]], left_on=\"geometry_idx\", right_on=\"index\", right_index=True ) If the training data is from labelled pixels in a raster, then the extracted data will contain a \"value\" column that contains the pixel labels: df_raster = stack.extract_raster(training_px)","title":"Extraction Training Data"},{"location":"mlworkflow/#model-training","text":"Next we can train a logistic regression classifier: from sklearn.linear_model import LogisticRegressionCV from sklearn.preprocessing import StandardScaler from sklearn.pipeline import Pipeline from sklearn.model_selection import cross_validate # define the classifier with standardization of the input features in a # pipeline lr = Pipeline( [('scaling', StandardScaler()), ('classifier', LogisticRegressionCV(n_jobs=-1))]) # remove NaNs from training data df_polygons = df_polygons.dropna() # fit the classifier X = df_polygons.drop(columns=[\"id\", \"label\", \"geometry\"]).values y = df_polygons[\"id\"].values lr.fit(X, y) After defining a classifier, a typical step consists of performing a cross-validation to evaluate the performance of the model. Scikit-learn provides the cross_validate function for this purpose. In comparison to non-spatial data, spatial data can be spatially correlated, which potentially can mean that geographically proximal samples may not represent truely independent samples if they are within the autocorrelation range of some of the predictors. This will lead to overly optimistic performance measures if samples in the training dataset / cross-validation partition are strongly spatially correlated with samples in the test dataset / cross-validation partition. In this case, performing cross-validation using groups is useful, because these groups can represent spatial clusters of training samples, and samples from the same group will never occur in both the training and test partitions of a cross-validation. Here we can use the polygon indices as the groups, i.e. pixels within the same polygon will not be split into training and test partitions: scores = cross_validate( estimator=lr, X=X, y=y, groups=df_polygons.index.droplevel(\"pixel_idx\"), scoring=\"accuracy\", cv=3, n_jobs=1, ) scores['test_score'].mean()","title":"Model Training"},{"location":"mlworkflow/#raster-prediction","text":"Prediction on the Raster object is performed using the predict method. The estimator is the only required argument. If the file_path argument is not specified then the result is automatically written to a temporary file. The predict method returns an rasterio.io.DatasetReader object which is open. # prediction result = stack.predict(estimator=lr, dtype='int16', nodata=0) result_probs = stack.predict_proba(estimator=lr) # plot classification result result.iloc[0].cmap = \"Dark2\" result.iloc[0].categorical = True result.plot() plt.show() The predict_proba method can be used to output class probabilities as a multi-band raster (a band for each class probability). In the latter case, indexes can also be supplied if you only want to output the probabilities for a particular class, or list of classes, by supplying the indices of those classes: # plot class probabilities result_probs.plot() plt.show()","title":"Raster Prediction"},{"location":"plotting/","text":"Plotting Both Raster and RasterLayer objects include basic plotting methods. The plot method for a RasterLayer object produces a single raster plot using the matplotlib.pyplot.imshow method. For convenience, plot settings such as color ramps and stretches can also be set for each RasterLayer using the RasterLayer.cmap that support matplotlib cmap's, and the RasterLayer.norm attribute to associate a matplotlib.colors.Normalize stretch with each RasterLayer: To plot a single RasterLayer: from pyspatialml import Raster from pyspatialml.datasets import nc stack = Raster([nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7]) # set RasterLayer color table stack.lsat7_2000_10.cmap = \"plasma\" # plot a single layer using an existing axis fig, ax = plt.subplots() stack.lsat7_2000_10.plot(ax=ax) plt.show() For RasterLayers that represent categorical data types, e.g. land cover, then the RasterLayer.categorical=True attribute will cause the cmap to be converted to a discrete scale. The default plot method for a Raster object produces a raster-matrix plot of the individual RasterLayers. By default this plot preserves the plotting attributes of the individual rasters: Plot all RasterLayers in a Raster object: stack.lsat7_2000_10.cmap = \"Blues\" stack.lsat7_2000_20.cmap = \"Greens\" stack.lsat7_2000_30.cmap = \"Reds\" stack.lsat7_2000_40.cmap = \"RdPu\" stack.lsat7_2000_50.cmap = \"autumn\" stack.lsat7_2000_70.cmap = \"hot\" stack.plot( title_fontsize=8, label_fontsize=6, legend_fontsize=6, names=[\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"], fig_kwds={\"figsize\": (8, 4)}, subplots_kwds={\"wspace\": 0.3} ) plt.show() The Raster.plot method also provides cmap and norm arguments that can be used to override the settings of the individual RasterLayers. Additional settings can be passed to control plot layout using the figure_kwds , legend_kwds and subplots_kwds arguments.","title":"Plotting"},{"location":"plotting/#plotting","text":"Both Raster and RasterLayer objects include basic plotting methods. The plot method for a RasterLayer object produces a single raster plot using the matplotlib.pyplot.imshow method. For convenience, plot settings such as color ramps and stretches can also be set for each RasterLayer using the RasterLayer.cmap that support matplotlib cmap's, and the RasterLayer.norm attribute to associate a matplotlib.colors.Normalize stretch with each RasterLayer: To plot a single RasterLayer: from pyspatialml import Raster from pyspatialml.datasets import nc stack = Raster([nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7]) # set RasterLayer color table stack.lsat7_2000_10.cmap = \"plasma\" # plot a single layer using an existing axis fig, ax = plt.subplots() stack.lsat7_2000_10.plot(ax=ax) plt.show() For RasterLayers that represent categorical data types, e.g. land cover, then the RasterLayer.categorical=True attribute will cause the cmap to be converted to a discrete scale. The default plot method for a Raster object produces a raster-matrix plot of the individual RasterLayers. By default this plot preserves the plotting attributes of the individual rasters: Plot all RasterLayers in a Raster object: stack.lsat7_2000_10.cmap = \"Blues\" stack.lsat7_2000_20.cmap = \"Greens\" stack.lsat7_2000_30.cmap = \"Reds\" stack.lsat7_2000_40.cmap = \"RdPu\" stack.lsat7_2000_50.cmap = \"autumn\" stack.lsat7_2000_70.cmap = \"hot\" stack.plot( title_fontsize=8, label_fontsize=6, legend_fontsize=6, names=[\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"], fig_kwds={\"figsize\": (8, 4)}, subplots_kwds={\"wspace\": 0.3} ) plt.show() The Raster.plot method also provides cmap and norm arguments that can be used to override the settings of the individual RasterLayers. Additional settings can be passed to control plot layout using the figure_kwds , legend_kwds and subplots_kwds arguments.","title":"Plotting"},{"location":"quickstart/","text":"Quickstart Initiating a Raster Object We are going to use a set of Landsat 7 bands contained within the nc example data: from pyspatialml import Raster import pyspatialml.datasets.nc as nc import matplotlib.pyplot as plt predictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7] These raster datasets are aligned in terms of their extent and coordinate reference systems. We can 'stack' these into a Raster class so that we can perform machine learning related operations on the set of rasters: stack = Raster(predictors) When a Raster object is created, the names to each layer are automatically created based on syntactically-correct versions of the file basenames: stack.names Color ramps and matplotlib.colors.Normalize objects can be assigned to each RasterLayer in the object using the cmap and norm attributes for convenient in plotting: stack.lsat7_2000_10.cmap = \"Blues\" stack.lsat7_2000_20.cmap = \"Greens\" stack.lsat7_2000_30.cmap = \"Reds\" stack.lsat7_2000_40.cmap = \"RdPu\" stack.lsat7_2000_50.cmap = \"autumn\" stack.lsat7_2000_70.cmap = \"hot\" stack.plot( title_fontsize=8, label_fontsize=6, legend_fontsize=6, names=[\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"], fig_kwds={\"figsize\": (8, 4)}, subplots_kwds={\"wspace\": 0.3} ) plt.show() Subsetting and Indexing Indexing of Raster objects is provided by several methods: The Raster[keys] method enables key-based indexing using a name of a RasterLayer, or a list of names. Direct subsetting of a Raster object instance returns a RasterLayer if only a single label is used, otherwise it always returns a new Raster object containing only the selected layers. The Raster.iloc[int, list, tuple, slice] method allows a Raster object instance to be subset using integer-based indexing or slicing. The iloc method returns a RasterLayer object if only a single index is used, otherwise it always returns a new Raster object containing only the selected layers. Subsetting of a Raster object instance can also occur by using attribute names in the form of Raster.name_of_layer . Because only a single RasterLayer can be subset at one time using this approach, a RasterLayer object is always returned. Examples of methods to subset a Raster object: # subset based on position single_layer = stack.iloc[0] # subset using a slice new_raster_obj = stack.iloc[0:3] # subset using labels single_layer = stack['lsat7_2000_10'] single_layer = stack.lsat7_2000_10 # list or tuple of keys new_raster_obj = stack[('lsat7_2000_10', 'lsat7_2000_20')] Iterate through RasterLayers individually: for name, layer in stack: print(layer) Replace a RasterLayer with another: stack.iloc[0] = Raster(nc.band7).iloc[0] Appending and Dropping Layers Append layers from another Raster to the stack. Duplicate names are automatically given a suffix. stack.append(Raster(nc.band7), in_place=True) stack.names Rename RasterLayers using a dict of old_name : new_name pairs: stack.names stack.rename({'lsat7_2000_30': 'new_name'}, in_place=True) stack.names stack.new_name stack['new_name'] Drop a RasterLayer: stack.names stack.drop(labels='lsat7_2000_70_1', in_place=True) stack.names Integration with Pandas Data from a Raster object can converted into a Pandas.DataDrame , with each pixel representing by a row, and columns reflecting the x, y coordinates and the values of each RasterLayer in the Raster object: import pandas as pd df = stack.to_pandas(max_pixels=50000, resampling='nearest') df.head() The original raster is up-sampled based on max_pixels and the resampling method, which uses all of resampling methods available in the underlying rasterio library for decimated reads. The Raster.to_pandas method can be useful for plotting datasets, or combining with a library such as plotnine to create ggplot2-style plots of stacks of RasterLayers: from plotnine import * (ggplot(df.melt(id_vars=['x', 'y']), aes(x='x', y='y', fill='value')) + geom_tile() + facet_wrap('variable')) Saving a Raster to File Save a Raster: import tempfile tmp_tif = tempfile.NamedTemporaryFile().name + '.tif' newstack = stack.write(file_path=tmp_tif, nodata=-9999) newstack.new_name.read() newstack = None","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#initiating-a-raster-object","text":"We are going to use a set of Landsat 7 bands contained within the nc example data: from pyspatialml import Raster import pyspatialml.datasets.nc as nc import matplotlib.pyplot as plt predictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7] These raster datasets are aligned in terms of their extent and coordinate reference systems. We can 'stack' these into a Raster class so that we can perform machine learning related operations on the set of rasters: stack = Raster(predictors) When a Raster object is created, the names to each layer are automatically created based on syntactically-correct versions of the file basenames: stack.names Color ramps and matplotlib.colors.Normalize objects can be assigned to each RasterLayer in the object using the cmap and norm attributes for convenient in plotting: stack.lsat7_2000_10.cmap = \"Blues\" stack.lsat7_2000_20.cmap = \"Greens\" stack.lsat7_2000_30.cmap = \"Reds\" stack.lsat7_2000_40.cmap = \"RdPu\" stack.lsat7_2000_50.cmap = \"autumn\" stack.lsat7_2000_70.cmap = \"hot\" stack.plot( title_fontsize=8, label_fontsize=6, legend_fontsize=6, names=[\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"], fig_kwds={\"figsize\": (8, 4)}, subplots_kwds={\"wspace\": 0.3} ) plt.show()","title":"Initiating a Raster Object"},{"location":"quickstart/#subsetting-and-indexing","text":"Indexing of Raster objects is provided by several methods: The Raster[keys] method enables key-based indexing using a name of a RasterLayer, or a list of names. Direct subsetting of a Raster object instance returns a RasterLayer if only a single label is used, otherwise it always returns a new Raster object containing only the selected layers. The Raster.iloc[int, list, tuple, slice] method allows a Raster object instance to be subset using integer-based indexing or slicing. The iloc method returns a RasterLayer object if only a single index is used, otherwise it always returns a new Raster object containing only the selected layers. Subsetting of a Raster object instance can also occur by using attribute names in the form of Raster.name_of_layer . Because only a single RasterLayer can be subset at one time using this approach, a RasterLayer object is always returned. Examples of methods to subset a Raster object: # subset based on position single_layer = stack.iloc[0] # subset using a slice new_raster_obj = stack.iloc[0:3] # subset using labels single_layer = stack['lsat7_2000_10'] single_layer = stack.lsat7_2000_10 # list or tuple of keys new_raster_obj = stack[('lsat7_2000_10', 'lsat7_2000_20')] Iterate through RasterLayers individually: for name, layer in stack: print(layer) Replace a RasterLayer with another: stack.iloc[0] = Raster(nc.band7).iloc[0]","title":"Subsetting and Indexing"},{"location":"quickstart/#appending-and-dropping-layers","text":"Append layers from another Raster to the stack. Duplicate names are automatically given a suffix. stack.append(Raster(nc.band7), in_place=True) stack.names Rename RasterLayers using a dict of old_name : new_name pairs: stack.names stack.rename({'lsat7_2000_30': 'new_name'}, in_place=True) stack.names stack.new_name stack['new_name'] Drop a RasterLayer: stack.names stack.drop(labels='lsat7_2000_70_1', in_place=True) stack.names","title":"Appending and Dropping Layers"},{"location":"quickstart/#integration-with-pandas","text":"Data from a Raster object can converted into a Pandas.DataDrame , with each pixel representing by a row, and columns reflecting the x, y coordinates and the values of each RasterLayer in the Raster object: import pandas as pd df = stack.to_pandas(max_pixels=50000, resampling='nearest') df.head() The original raster is up-sampled based on max_pixels and the resampling method, which uses all of resampling methods available in the underlying rasterio library for decimated reads. The Raster.to_pandas method can be useful for plotting datasets, or combining with a library such as plotnine to create ggplot2-style plots of stacks of RasterLayers: from plotnine import * (ggplot(df.melt(id_vars=['x', 'y']), aes(x='x', y='y', fill='value')) + geom_tile() + facet_wrap('variable'))","title":"Integration with Pandas"},{"location":"quickstart/#saving-a-raster-to-file","text":"Save a Raster: import tempfile tmp_tif = tempfile.NamedTemporaryFile().name + '.tif' newstack = stack.write(file_path=tmp_tif, nodata=-9999) newstack.new_name.read() newstack = None","title":"Saving a Raster to File"},{"location":"sampling/","text":"Random Sampling Random Uniform Sampling For many spatial models, it is common to take a random sample of the predictors to represent a single class (i.e. an environmental background or pseudo-absences in a binary classification model). The sample function is supplied in the sampling module for this purpose: # extract training data using a random sample df_rand = stack.sample(size=1000, random_state=1) df_rand.plot() Stratified Random Sampling The sample function also enables stratified random sampling based on passing a categorical raster dataset to the strata argument. The categorical raster should spatially overlap with the dataset to be sampled, but it does not need to be of the same grid resolution. This raster should be passed as a opened rasterio dataset: with rasterio.open(nc.strata) as strata: df_strata = stack.sample(size=5, strata=strata, random_state=1) df_strata = df_strata.dropna() fig, ax = plt.subplots() ax.imshow( data=strata.read(1, masked=True), extent=rasterio.plot.plotting_extent(strata), cmap='tab10') df_strata.plot(ax=ax, markersize=20, color='white') plt.show()","title":"Sampling"},{"location":"sampling/#random-sampling","text":"","title":"Random Sampling"},{"location":"sampling/#random-uniform-sampling","text":"For many spatial models, it is common to take a random sample of the predictors to represent a single class (i.e. an environmental background or pseudo-absences in a binary classification model). The sample function is supplied in the sampling module for this purpose: # extract training data using a random sample df_rand = stack.sample(size=1000, random_state=1) df_rand.plot()","title":"Random Uniform Sampling"},{"location":"sampling/#stratified-random-sampling","text":"The sample function also enables stratified random sampling based on passing a categorical raster dataset to the strata argument. The categorical raster should spatially overlap with the dataset to be sampled, but it does not need to be of the same grid resolution. This raster should be passed as a opened rasterio dataset: with rasterio.open(nc.strata) as strata: df_strata = stack.sample(size=5, strata=strata, random_state=1) df_strata = df_strata.dropna() fig, ax = plt.subplots() ax.imshow( data=strata.read(1, masked=True), extent=rasterio.plot.plotting_extent(strata), cmap='tab10') df_strata.plot(ax=ax, markersize=20, color='white') plt.show()","title":"Stratified Random Sampling"},{"location":"transformers/","text":"Transformers Spatial Lag Transformer A transformer to create spatial lag variables by using a weighted mean/mode of the values of the K-neighboring observations. The weighted mean/mode of the surrounding observations are appended as a new feature to the right-most column in the training data. The measure parameter should be set to 'mode' for classification, and 'mean' for regression. KNNTransformer(n_neighbors=7, weights=\"distance\", measure=\"mean\", radius=1.0, algorithm=\"auto\", leaf_size=30, metric=\"minkowski\", p=2, normalize=True, metric_params=None, kernel_params=None, n_jobs=1) GeoDistTransformer A common spatial feature engineering task is to create new features that describe the proximity to some reference locations. The GeoDistTransformer can be used to add these features as part of a machine learning pipeline. GeoDistTransformer(refs, log=False) Where refs are an array of coordinates of reference locations in (m, n-dimensional) order, such as {n_locations, x_coordinates, y_coordinates, ...} for as many dimensions as required. For example to calculate distances to a single x,y,z location: refs = [-57.345, -110.134, 1012] And to calculate distances to three x,y reference locations: refs = [ [-57.345, -110.134], [-56.345, -109.123], [-58.534, -112.123] ] The supplied array has to have at least x,y coordinates with a (1, 2) shape for a single location.","title":"Spatial transformers"},{"location":"transformers/#transformers","text":"","title":"Transformers"},{"location":"transformers/#spatial-lag-transformer","text":"A transformer to create spatial lag variables by using a weighted mean/mode of the values of the K-neighboring observations. The weighted mean/mode of the surrounding observations are appended as a new feature to the right-most column in the training data. The measure parameter should be set to 'mode' for classification, and 'mean' for regression. KNNTransformer(n_neighbors=7, weights=\"distance\", measure=\"mean\", radius=1.0, algorithm=\"auto\", leaf_size=30, metric=\"minkowski\", p=2, normalize=True, metric_params=None, kernel_params=None, n_jobs=1)","title":"Spatial Lag Transformer"},{"location":"transformers/#geodisttransformer","text":"A common spatial feature engineering task is to create new features that describe the proximity to some reference locations. The GeoDistTransformer can be used to add these features as part of a machine learning pipeline. GeoDistTransformer(refs, log=False) Where refs are an array of coordinates of reference locations in (m, n-dimensional) order, such as {n_locations, x_coordinates, y_coordinates, ...} for as many dimensions as required. For example to calculate distances to a single x,y,z location: refs = [-57.345, -110.134, 1012] And to calculate distances to three x,y reference locations: refs = [ [-57.345, -110.134], [-56.345, -109.123], [-58.534, -112.123] ] The supplied array has to have at least x,y coordinates with a (1, 2) shape for a single location.","title":"GeoDistTransformer"}]}