{
  "hash": "1ddec99dd2cca1a0e802081725fd4c4e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Quick start\nformat:\n  html:\n    code-fold: false\n    toc: true\n---\n\n## Initiating a Raster Object\n\nWe are going to use a set of Landsat 7 bands contained within the nc example\ndata:\n\n::: {#4cb5727a .cell execution_count=1}\n``` {.python .cell-code}\nfrom pyspatialml import Raster\nimport pyspatialml.datasets.nc as nc\nimport matplotlib.pyplot as plt\n\npredictors = [nc.band1, nc.band2, nc.band3, nc.band4, nc.band5, nc.band7]\n```\n:::\n\n\nThese raster datasets are aligned in terms of their extent and coordinate\nreference systems. We can 'stack' these into a Raster class so that we can\nperform machine learning related operations on the set of rasters:\n\n::: {#22e619cd .cell execution_count=2}\n``` {.python .cell-code}\nstack = Raster(predictors)\n```\n:::\n\n\nWhen a Raster object is created, the names to each layer are automatically\ncreated based on syntactically-correct versions of the file basenames:\n\n::: {#df26959e .cell execution_count=3}\n``` {.python .cell-code}\nstack.names\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\ndict_keys(['lsat7_2000_10', 'lsat7_2000_20', 'lsat7_2000_30', 'lsat7_2000_40', 'lsat7_2000_50', 'lsat7_2000_70'])\n```\n:::\n:::\n\n\nColor ramps and matplotlib.colors.Normalize objects can be assigned to each\nRasterLayer in the object using the `cmap` and `norm` attributes for\nconvenient in plotting:\n\n::: {#1cd341e5 .cell execution_count=4}\n``` {.python .cell-code}\nstack.lsat7_2000_10.cmap = \"Blues\"\nstack.lsat7_2000_20.cmap = \"Greens\"\nstack.lsat7_2000_30.cmap = \"Reds\"\nstack.lsat7_2000_40.cmap = \"RdPu\"\nstack.lsat7_2000_50.cmap = \"autumn\"\nstack.lsat7_2000_70.cmap = \"hot\"\n\nstack.plot(\n    title_fontsize=8,\n    label_fontsize=6,\n    legend_fontsize=6,\n    names=[\"B1\", \"B2\", \"B3\", \"B4\", \"B5\", \"B7\"],\n    fig_kwds={\"figsize\": (8, 4)},\n    subplots_kwds={\"wspace\": 0.3}\n)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](quickstart_files/figure-html/cell-5-output-1.png){width=679 height=342}\n:::\n:::\n\n\n## Subsetting and Indexing\n\nIndexing of Raster objects is provided by several methods:\n\nThe ``Raster[keys]`` method enables key-based indexing using a name of a\nRasterLayer, or a list of names. Direct subsetting of a Raster object instance\nreturns a RasterLayer if only a single label is used, otherwise it always\nreturns a new Raster object containing only the selected layers.\n\nThe ``Raster.iloc[int, list, tuple, slice]`` method allows a Raster object\ninstance to be subset using integer-based indexing or slicing. The ``iloc``\nmethod returns a RasterLayer object if only a single index is used, otherwise\nit always returns a new Raster object containing only the selected layers.\n\nSubsetting of a Raster object instance can also occur by using attribute names\nin the form of ``Raster.name_of_layer``. Because only a single RasterLayer can\nbe subset at one time using this approach, a RasterLayer object is always\nreturned.\n\nExamples of methods to subset a Raster object:\n\n::: {#fdbfb00a .cell execution_count=5}\n``` {.python .cell-code}\n# subset based on position\nsingle_layer = stack.iloc[0]\n\n# subset using a slice\nnew_raster_obj = stack.iloc[0:3]\n\n# subset using labels\nsingle_layer = stack['lsat7_2000_10']\nsingle_layer = stack.lsat7_2000_10\n\n# list or tuple of keys\nnew_raster_obj = stack[('lsat7_2000_10', 'lsat7_2000_20')]\n```\n:::\n\n\nIterate through RasterLayers individually:\n\n::: {#d38cee29 .cell execution_count=6}\n``` {.python .cell-code}\nfor name, layer in stack.items():\n    print(name, layer)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlsat7_2000_10 <pyspatialml.rasterlayer.RasterLayer object at 0x17fb6b650>\nlsat7_2000_20 <pyspatialml.rasterlayer.RasterLayer object at 0x11e5d21d0>\nlsat7_2000_30 <pyspatialml.rasterlayer.RasterLayer object at 0x16d168bd0>\nlsat7_2000_40 <pyspatialml.rasterlayer.RasterLayer object at 0x17f80cc90>\nlsat7_2000_50 <pyspatialml.rasterlayer.RasterLayer object at 0x17fb6a110>\nlsat7_2000_70 <pyspatialml.rasterlayer.RasterLayer object at 0x17fd92510>\n```\n:::\n:::\n\n\nReplace a RasterLayer with another:\n\n::: {#a66d0bd5 .cell execution_count=7}\n``` {.python .cell-code}\nstack.iloc[0] = Raster(nc.band7).iloc[0]\n\nstack.iloc[0].plot()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](quickstart_files/figure-html/cell-8-output-1.png){width=499 height=413}\n:::\n:::\n\n\n## Appending and Dropping Layers\n\nAppend layers from another Raster to the stack. Duplicate names are\nautomatically given a suffix.\n\n::: {#9d580c66 .cell execution_count=8}\n``` {.python .cell-code}\nstack.append(Raster(nc.band7), in_place=True)\nstack.names\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\ndict_keys(['lsat7_2000_10', 'lsat7_2000_20', 'lsat7_2000_30', 'lsat7_2000_40', 'lsat7_2000_50', 'lsat7_2000_70_1', 'lsat7_2000_70_2'])\n```\n:::\n:::\n\n\nRename RasterLayers using a dict of old_name : new_name pairs:\n\n::: {#35b931db .cell execution_count=9}\n``` {.python .cell-code}\nstack.names\nstack.rename({'lsat7_2000_30': 'new_name'}, in_place=True)\nstack.names\nstack.new_name\nstack['new_name']\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n<pyspatialml.rasterlayer.RasterLayer at 0x16d168bd0>\n```\n:::\n:::\n\n\nDrop a RasterLayer:\n\n::: {#7517a32e .cell execution_count=10}\n``` {.python .cell-code}\nstack.names\nstack.drop(labels='lsat7_2000_70_1', in_place=True)\nstack.names\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\ndict_keys(['lsat7_2000_10', 'lsat7_2000_20', 'new_name', 'lsat7_2000_40', 'lsat7_2000_50', 'lsat7_2000_70_2'])\n```\n:::\n:::\n\n\n## Integration with Pandas\n\nData from a Raster object can converted into a `Pandas.DataDrame`, with each\npixel representing by a row, and columns reflecting the x, y coordinates and\nthe values of each RasterLayer in the Raster object:\n\n::: {#62ad6b48 .cell execution_count=11}\n``` {.python .cell-code}\nimport pandas as pd\n\ndf = stack.to_pandas(max_pixels=50000, resampling='nearest')\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>x</th>\n      <th>y</th>\n      <th>lsat7_2000_10</th>\n      <th>lsat7_2000_20</th>\n      <th>new_name</th>\n      <th>lsat7_2000_40</th>\n      <th>lsat7_2000_50</th>\n      <th>lsat7_2000_70_2</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>630534.000000</td>\n      <td>228114.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>630562.558402</td>\n      <td>228114.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>630591.116803</td>\n      <td>228114.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>630619.675205</td>\n      <td>228114.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>630648.233607</td>\n      <td>228114.0</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe original raster is up-sampled based on max_pixels and the resampling\nmethod, which uses all of resampling methods available in the underlying\nrasterio library for decimated reads.\n\n## Saving a Raster to File\n\nSave a Raster:\n\n::: {#a5671c9d .cell execution_count=12}\n``` {.python .cell-code}\nimport tempfile\n\ntmp_tif = tempfile.NamedTemporaryFile().name + '.tif'\nnewstack = stack.write(file_path=tmp_tif, nodata=-9999)\nnewstack.new_name.read()\nnewstack = None\n```\n:::\n\n\n",
    "supporting": [
      "quickstart_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}